
final_project_m2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002388  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  00002388  0000241c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800088  00800088  00002444  2**0
                  ALLOC
  3 .stab         000028bc  00000000  00000000  00002444  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001392  00000000  00000000  00004d00  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00006092  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000061d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00006342  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00007f8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00008e76  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00009c24  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00009d84  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000a011  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000a7df  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 51 0f 	jmp	0x1ea2	; 0x1ea2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 1e 0f 	jmp	0x1e3c	; 0x1e3c <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e8       	ldi	r30, 0x88	; 136
      68:	f3 e2       	ldi	r31, 0x23	; 35
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 38       	cpi	r26, 0x88	; 136
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a8 e8       	ldi	r26, 0x88	; 136
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 38       	cpi	r26, 0x8D	; 141
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 aa 09 	call	0x1354	; 0x1354 <main>
      8a:	0c 94 c2 11 	jmp	0x2384	; 0x2384 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 8b 11 	jmp	0x2316	; 0x2316 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 97 11 	jmp	0x232e	; 0x232e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 97 11 	jmp	0x232e	; 0x232e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 8b 11 	jmp	0x2316	; 0x2316 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 97 11 	jmp	0x232e	; 0x232e <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 97 11 	jmp	0x232e	; 0x232e <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 97 11 	jmp	0x232e	; 0x232e <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 9b 11 	jmp	0x2336	; 0x2336 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <Buzzer_init>:
    Setup the direction for the buzzer pin as output pin
    through the GPIO driver.
   Inputs: None
   Return: None
 */
void Buzzer_init(){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_ID,BUZZER_PIN_ID,PIN_OUTPUT);
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	66 e0       	ldi	r22, 0x06	; 6
     b52:	41 e0       	ldi	r20, 0x01	; 1
     b54:	0e 94 68 06 	call	0xcd0	; 0xcd0 <GPIO_setupPinDirection>

}
     b58:	cf 91       	pop	r28
     b5a:	df 91       	pop	r29
     b5c:	08 95       	ret

00000b5e <Buzzer_on>:
 *  Description :
        Function to enable the Buzzer through the GPIO.
    Inputs: None
    Return: None
 */
void Buzzer_on(void){
     b5e:	df 93       	push	r29
     b60:	cf 93       	push	r28
     b62:	cd b7       	in	r28, 0x3d	; 61
     b64:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID , BUZZER_PIN_ID ,LOGIC_HIGH);
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	66 e0       	ldi	r22, 0x06	; 6
     b6a:	41 e0       	ldi	r20, 0x01	; 1
     b6c:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
}
     b70:	cf 91       	pop	r28
     b72:	df 91       	pop	r29
     b74:	08 95       	ret

00000b76 <Buzzer_off>:
   	   Function to disable the Buzzer through the GPIO.
   Inputs: None
   Return: No
 *
 */
void Buzzer_off(void){
     b76:	df 93       	push	r29
     b78:	cf 93       	push	r28
     b7a:	cd b7       	in	r28, 0x3d	; 61
     b7c:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID , BUZZER_PIN_ID ,LOGIC_LOW);
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	66 e0       	ldi	r22, 0x06	; 6
     b82:	40 e0       	ldi	r20, 0x00	; 0
     b84:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
}
     b88:	cf 91       	pop	r28
     b8a:	df 91       	pop	r29
     b8c:	08 95       	ret

00000b8e <EEPROM_writeByte>:
 *******************************************************************************/
#include "external_eeprom.h"
#include "twi.h"

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
     b8e:	df 93       	push	r29
     b90:	cf 93       	push	r28
     b92:	00 d0       	rcall	.+0      	; 0xb94 <EEPROM_writeByte+0x6>
     b94:	00 d0       	rcall	.+0      	; 0xb96 <EEPROM_writeByte+0x8>
     b96:	cd b7       	in	r28, 0x3d	; 61
     b98:	de b7       	in	r29, 0x3e	; 62
     b9a:	9a 83       	std	Y+2, r25	; 0x02
     b9c:	89 83       	std	Y+1, r24	; 0x01
     b9e:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
     ba0:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <TWI_start>
    if (TWI_getStatus() != TWI_START)
     ba4:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     ba8:	88 30       	cpi	r24, 0x08	; 8
     baa:	11 f0       	breq	.+4      	; 0xbb0 <EEPROM_writeByte+0x22>
        return ERROR;
     bac:	1c 82       	std	Y+4, r1	; 0x04
     bae:	28 c0       	rjmp	.+80     	; 0xc00 <EEPROM_writeByte+0x72>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	80 70       	andi	r24, 0x00	; 0
     bb6:	97 70       	andi	r25, 0x07	; 7
     bb8:	88 0f       	add	r24, r24
     bba:	89 2f       	mov	r24, r25
     bbc:	88 1f       	adc	r24, r24
     bbe:	99 0b       	sbc	r25, r25
     bc0:	91 95       	neg	r25
     bc2:	80 6a       	ori	r24, 0xA0	; 160
     bc4:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
     bc8:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     bcc:	88 31       	cpi	r24, 0x18	; 24
     bce:	11 f0       	breq	.+4      	; 0xbd4 <EEPROM_writeByte+0x46>
        return ERROR; 
     bd0:	1c 82       	std	Y+4, r1	; 0x04
     bd2:	16 c0       	rjmp	.+44     	; 0xc00 <EEPROM_writeByte+0x72>
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
     bd4:	89 81       	ldd	r24, Y+1	; 0x01
     bd6:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     bda:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     bde:	88 32       	cpi	r24, 0x28	; 40
     be0:	11 f0       	breq	.+4      	; 0xbe6 <EEPROM_writeByte+0x58>
        return ERROR;
     be2:	1c 82       	std	Y+4, r1	; 0x04
     be4:	0d c0       	rjmp	.+26     	; 0xc00 <EEPROM_writeByte+0x72>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);
     be6:	8b 81       	ldd	r24, Y+3	; 0x03
     be8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     bec:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     bf0:	88 32       	cpi	r24, 0x28	; 40
     bf2:	11 f0       	breq	.+4      	; 0xbf8 <EEPROM_writeByte+0x6a>
        return ERROR;
     bf4:	1c 82       	std	Y+4, r1	; 0x04
     bf6:	04 c0       	rjmp	.+8      	; 0xc00 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
     bf8:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <TWI_stop>
	
    return SUCCESS;
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	8c 83       	std	Y+4, r24	; 0x04
     c00:	8c 81       	ldd	r24, Y+4	; 0x04
}
     c02:	0f 90       	pop	r0
     c04:	0f 90       	pop	r0
     c06:	0f 90       	pop	r0
     c08:	0f 90       	pop	r0
     c0a:	cf 91       	pop	r28
     c0c:	df 91       	pop	r29
     c0e:	08 95       	ret

00000c10 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
     c10:	df 93       	push	r29
     c12:	cf 93       	push	r28
     c14:	00 d0       	rcall	.+0      	; 0xc16 <EEPROM_readByte+0x6>
     c16:	00 d0       	rcall	.+0      	; 0xc18 <EEPROM_readByte+0x8>
     c18:	0f 92       	push	r0
     c1a:	cd b7       	in	r28, 0x3d	; 61
     c1c:	de b7       	in	r29, 0x3e	; 62
     c1e:	9a 83       	std	Y+2, r25	; 0x02
     c20:	89 83       	std	Y+1, r24	; 0x01
     c22:	7c 83       	std	Y+4, r23	; 0x04
     c24:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
     c26:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <TWI_start>
    if (TWI_getStatus() != TWI_START)
     c2a:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     c2e:	88 30       	cpi	r24, 0x08	; 8
     c30:	11 f0       	breq	.+4      	; 0xc36 <EEPROM_readByte+0x26>
        return ERROR;
     c32:	1d 82       	std	Y+5, r1	; 0x05
     c34:	44 c0       	rjmp	.+136    	; 0xcbe <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));
     c36:	89 81       	ldd	r24, Y+1	; 0x01
     c38:	9a 81       	ldd	r25, Y+2	; 0x02
     c3a:	80 70       	andi	r24, 0x00	; 0
     c3c:	97 70       	andi	r25, 0x07	; 7
     c3e:	88 0f       	add	r24, r24
     c40:	89 2f       	mov	r24, r25
     c42:	88 1f       	adc	r24, r24
     c44:	99 0b       	sbc	r25, r25
     c46:	91 95       	neg	r25
     c48:	80 6a       	ori	r24, 0xA0	; 160
     c4a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
     c4e:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     c52:	88 31       	cpi	r24, 0x18	; 24
     c54:	11 f0       	breq	.+4      	; 0xc5a <EEPROM_readByte+0x4a>
        return ERROR;
     c56:	1d 82       	std	Y+5, r1	; 0x05
     c58:	32 c0       	rjmp	.+100    	; 0xcbe <EEPROM_readByte+0xae>
		
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
     c5a:	89 81       	ldd	r24, Y+1	; 0x01
     c5c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     c60:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     c64:	88 32       	cpi	r24, 0x28	; 40
     c66:	11 f0       	breq	.+4      	; 0xc6c <EEPROM_readByte+0x5c>
        return ERROR;
     c68:	1d 82       	std	Y+5, r1	; 0x05
     c6a:	29 c0       	rjmp	.+82     	; 0xcbe <EEPROM_readByte+0xae>
		
    /* Send the Repeated Start Bit */
    TWI_start();
     c6c:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <TWI_start>
    if (TWI_getStatus() != TWI_REP_START)
     c70:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     c74:	80 31       	cpi	r24, 0x10	; 16
     c76:	11 f0       	breq	.+4      	; 0xc7c <EEPROM_readByte+0x6c>
        return ERROR;
     c78:	1d 82       	std	Y+5, r1	; 0x05
     c7a:	21 c0       	rjmp	.+66     	; 0xcbe <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));
     c7c:	89 81       	ldd	r24, Y+1	; 0x01
     c7e:	9a 81       	ldd	r25, Y+2	; 0x02
     c80:	80 70       	andi	r24, 0x00	; 0
     c82:	97 70       	andi	r25, 0x07	; 7
     c84:	88 0f       	add	r24, r24
     c86:	89 2f       	mov	r24, r25
     c88:	88 1f       	adc	r24, r24
     c8a:	99 0b       	sbc	r25, r25
     c8c:	91 95       	neg	r25
     c8e:	81 6a       	ori	r24, 0xA1	; 161
     c90:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
     c94:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     c98:	80 34       	cpi	r24, 0x40	; 64
     c9a:	11 f0       	breq	.+4      	; 0xca0 <EEPROM_readByte+0x90>
        return ERROR;
     c9c:	1d 82       	std	Y+5, r1	; 0x05
     c9e:	0f c0       	rjmp	.+30     	; 0xcbe <EEPROM_readByte+0xae>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readByteWithNACK();
     ca0:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <TWI_readByteWithNACK>
     ca4:	eb 81       	ldd	r30, Y+3	; 0x03
     ca6:	fc 81       	ldd	r31, Y+4	; 0x04
     ca8:	80 83       	st	Z, r24
    if (TWI_getStatus() != TWI_MR_DATA_NACK)
     caa:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <TWI_getStatus>
     cae:	88 35       	cpi	r24, 0x58	; 88
     cb0:	11 f0       	breq	.+4      	; 0xcb6 <EEPROM_readByte+0xa6>
        return ERROR;
     cb2:	1d 82       	std	Y+5, r1	; 0x05
     cb4:	04 c0       	rjmp	.+8      	; 0xcbe <EEPROM_readByte+0xae>

    /* Send the Stop Bit */
    TWI_stop();
     cb6:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <TWI_stop>

    return SUCCESS;
     cba:	81 e0       	ldi	r24, 0x01	; 1
     cbc:	8d 83       	std	Y+5, r24	; 0x05
     cbe:	8d 81       	ldd	r24, Y+5	; 0x05
}
     cc0:	0f 90       	pop	r0
     cc2:	0f 90       	pop	r0
     cc4:	0f 90       	pop	r0
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	cf 91       	pop	r28
     ccc:	df 91       	pop	r29
     cce:	08 95       	ret

00000cd0 <GPIO_setupPinDirection>:
/* description :
 * setup  the direction of the required pin input/output.
 * if the input port number or pin number are not correct \
 * the function will not handle the request
 */
void GPIO_setupPinDirection(uint8 port_num,uint8 pin_num,GPIO_PinDirectionType direction){
     cd0:	df 93       	push	r29
     cd2:	cf 93       	push	r28
     cd4:	00 d0       	rcall	.+0      	; 0xcd6 <GPIO_setupPinDirection+0x6>
     cd6:	00 d0       	rcall	.+0      	; 0xcd8 <GPIO_setupPinDirection+0x8>
     cd8:	0f 92       	push	r0
     cda:	cd b7       	in	r28, 0x3d	; 61
     cdc:	de b7       	in	r29, 0x3e	; 62
     cde:	89 83       	std	Y+1, r24	; 0x01
     ce0:	6a 83       	std	Y+2, r22	; 0x02
     ce2:	4b 83       	std	Y+3, r20	; 0x03
	if((port_num >= NUM_OF_PORTS) || (pin_num >=NUM_OF_PINS)){
     ce4:	89 81       	ldd	r24, Y+1	; 0x01
     ce6:	84 30       	cpi	r24, 0x04	; 4
     ce8:	08 f0       	brcs	.+2      	; 0xcec <GPIO_setupPinDirection+0x1c>
     cea:	d5 c0       	rjmp	.+426    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
     cec:	8a 81       	ldd	r24, Y+2	; 0x02
     cee:	88 30       	cpi	r24, 0x08	; 8
     cf0:	08 f0       	brcs	.+2      	; 0xcf4 <GPIO_setupPinDirection+0x24>
     cf2:	d1 c0       	rjmp	.+418    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
		/*     Do Nothing     */
	}
	else {
		switch(port_num)   // checking on the port to operate on it
     cf4:	89 81       	ldd	r24, Y+1	; 0x01
     cf6:	28 2f       	mov	r18, r24
     cf8:	30 e0       	ldi	r19, 0x00	; 0
     cfa:	3d 83       	std	Y+5, r19	; 0x05
     cfc:	2c 83       	std	Y+4, r18	; 0x04
     cfe:	8c 81       	ldd	r24, Y+4	; 0x04
     d00:	9d 81       	ldd	r25, Y+5	; 0x05
     d02:	81 30       	cpi	r24, 0x01	; 1
     d04:	91 05       	cpc	r25, r1
     d06:	09 f4       	brne	.+2      	; 0xd0a <GPIO_setupPinDirection+0x3a>
     d08:	43 c0       	rjmp	.+134    	; 0xd90 <GPIO_setupPinDirection+0xc0>
     d0a:	2c 81       	ldd	r18, Y+4	; 0x04
     d0c:	3d 81       	ldd	r19, Y+5	; 0x05
     d0e:	22 30       	cpi	r18, 0x02	; 2
     d10:	31 05       	cpc	r19, r1
     d12:	2c f4       	brge	.+10     	; 0xd1e <GPIO_setupPinDirection+0x4e>
     d14:	8c 81       	ldd	r24, Y+4	; 0x04
     d16:	9d 81       	ldd	r25, Y+5	; 0x05
     d18:	00 97       	sbiw	r24, 0x00	; 0
     d1a:	71 f0       	breq	.+28     	; 0xd38 <GPIO_setupPinDirection+0x68>
     d1c:	bc c0       	rjmp	.+376    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
     d1e:	2c 81       	ldd	r18, Y+4	; 0x04
     d20:	3d 81       	ldd	r19, Y+5	; 0x05
     d22:	22 30       	cpi	r18, 0x02	; 2
     d24:	31 05       	cpc	r19, r1
     d26:	09 f4       	brne	.+2      	; 0xd2a <GPIO_setupPinDirection+0x5a>
     d28:	5f c0       	rjmp	.+190    	; 0xde8 <GPIO_setupPinDirection+0x118>
     d2a:	8c 81       	ldd	r24, Y+4	; 0x04
     d2c:	9d 81       	ldd	r25, Y+5	; 0x05
     d2e:	83 30       	cpi	r24, 0x03	; 3
     d30:	91 05       	cpc	r25, r1
     d32:	09 f4       	brne	.+2      	; 0xd36 <GPIO_setupPinDirection+0x66>
     d34:	85 c0       	rjmp	.+266    	; 0xe40 <GPIO_setupPinDirection+0x170>
     d36:	af c0       	rjmp	.+350    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT){
     d38:	8b 81       	ldd	r24, Y+3	; 0x03
     d3a:	81 30       	cpi	r24, 0x01	; 1
     d3c:	a1 f4       	brne	.+40     	; 0xd66 <GPIO_setupPinDirection+0x96>
				SET_BIT(DDRA,pin_num); // setting the required pin to make it output
     d3e:	aa e3       	ldi	r26, 0x3A	; 58
     d40:	b0 e0       	ldi	r27, 0x00	; 0
     d42:	ea e3       	ldi	r30, 0x3A	; 58
     d44:	f0 e0       	ldi	r31, 0x00	; 0
     d46:	80 81       	ld	r24, Z
     d48:	48 2f       	mov	r20, r24
     d4a:	8a 81       	ldd	r24, Y+2	; 0x02
     d4c:	28 2f       	mov	r18, r24
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	90 e0       	ldi	r25, 0x00	; 0
     d54:	02 2e       	mov	r0, r18
     d56:	02 c0       	rjmp	.+4      	; 0xd5c <GPIO_setupPinDirection+0x8c>
     d58:	88 0f       	add	r24, r24
     d5a:	99 1f       	adc	r25, r25
     d5c:	0a 94       	dec	r0
     d5e:	e2 f7       	brpl	.-8      	; 0xd58 <GPIO_setupPinDirection+0x88>
     d60:	84 2b       	or	r24, r20
     d62:	8c 93       	st	X, r24
     d64:	98 c0       	rjmp	.+304    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			else{
				CLEAR_BIT(DDRA,pin_num); // clearing the corresponding bit to make the bit input
     d66:	aa e3       	ldi	r26, 0x3A	; 58
     d68:	b0 e0       	ldi	r27, 0x00	; 0
     d6a:	ea e3       	ldi	r30, 0x3A	; 58
     d6c:	f0 e0       	ldi	r31, 0x00	; 0
     d6e:	80 81       	ld	r24, Z
     d70:	48 2f       	mov	r20, r24
     d72:	8a 81       	ldd	r24, Y+2	; 0x02
     d74:	28 2f       	mov	r18, r24
     d76:	30 e0       	ldi	r19, 0x00	; 0
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	02 2e       	mov	r0, r18
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <GPIO_setupPinDirection+0xb4>
     d80:	88 0f       	add	r24, r24
     d82:	99 1f       	adc	r25, r25
     d84:	0a 94       	dec	r0
     d86:	e2 f7       	brpl	.-8      	; 0xd80 <GPIO_setupPinDirection+0xb0>
     d88:	80 95       	com	r24
     d8a:	84 23       	and	r24, r20
     d8c:	8c 93       	st	X, r24
     d8e:	83 c0       	rjmp	.+262    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			break;

		case PORTB_ID:
			if(direction == PIN_OUTPUT){
     d90:	8b 81       	ldd	r24, Y+3	; 0x03
     d92:	81 30       	cpi	r24, 0x01	; 1
     d94:	a1 f4       	brne	.+40     	; 0xdbe <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB,pin_num);
     d96:	a7 e3       	ldi	r26, 0x37	; 55
     d98:	b0 e0       	ldi	r27, 0x00	; 0
     d9a:	e7 e3       	ldi	r30, 0x37	; 55
     d9c:	f0 e0       	ldi	r31, 0x00	; 0
     d9e:	80 81       	ld	r24, Z
     da0:	48 2f       	mov	r20, r24
     da2:	8a 81       	ldd	r24, Y+2	; 0x02
     da4:	28 2f       	mov	r18, r24
     da6:	30 e0       	ldi	r19, 0x00	; 0
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	90 e0       	ldi	r25, 0x00	; 0
     dac:	02 2e       	mov	r0, r18
     dae:	02 c0       	rjmp	.+4      	; 0xdb4 <GPIO_setupPinDirection+0xe4>
     db0:	88 0f       	add	r24, r24
     db2:	99 1f       	adc	r25, r25
     db4:	0a 94       	dec	r0
     db6:	e2 f7       	brpl	.-8      	; 0xdb0 <GPIO_setupPinDirection+0xe0>
     db8:	84 2b       	or	r24, r20
     dba:	8c 93       	st	X, r24
     dbc:	6c c0       	rjmp	.+216    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			else{
				CLEAR_BIT(DDRB,pin_num);
     dbe:	a7 e3       	ldi	r26, 0x37	; 55
     dc0:	b0 e0       	ldi	r27, 0x00	; 0
     dc2:	e7 e3       	ldi	r30, 0x37	; 55
     dc4:	f0 e0       	ldi	r31, 0x00	; 0
     dc6:	80 81       	ld	r24, Z
     dc8:	48 2f       	mov	r20, r24
     dca:	8a 81       	ldd	r24, Y+2	; 0x02
     dcc:	28 2f       	mov	r18, r24
     dce:	30 e0       	ldi	r19, 0x00	; 0
     dd0:	81 e0       	ldi	r24, 0x01	; 1
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	02 2e       	mov	r0, r18
     dd6:	02 c0       	rjmp	.+4      	; 0xddc <GPIO_setupPinDirection+0x10c>
     dd8:	88 0f       	add	r24, r24
     dda:	99 1f       	adc	r25, r25
     ddc:	0a 94       	dec	r0
     dde:	e2 f7       	brpl	.-8      	; 0xdd8 <GPIO_setupPinDirection+0x108>
     de0:	80 95       	com	r24
     de2:	84 23       	and	r24, r20
     de4:	8c 93       	st	X, r24
     de6:	57 c0       	rjmp	.+174    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT){
     de8:	8b 81       	ldd	r24, Y+3	; 0x03
     dea:	81 30       	cpi	r24, 0x01	; 1
     dec:	a1 f4       	brne	.+40     	; 0xe16 <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC,pin_num);
     dee:	a4 e3       	ldi	r26, 0x34	; 52
     df0:	b0 e0       	ldi	r27, 0x00	; 0
     df2:	e4 e3       	ldi	r30, 0x34	; 52
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	48 2f       	mov	r20, r24
     dfa:	8a 81       	ldd	r24, Y+2	; 0x02
     dfc:	28 2f       	mov	r18, r24
     dfe:	30 e0       	ldi	r19, 0x00	; 0
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	02 2e       	mov	r0, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <GPIO_setupPinDirection+0x13c>
     e08:	88 0f       	add	r24, r24
     e0a:	99 1f       	adc	r25, r25
     e0c:	0a 94       	dec	r0
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <GPIO_setupPinDirection+0x138>
     e10:	84 2b       	or	r24, r20
     e12:	8c 93       	st	X, r24
     e14:	40 c0       	rjmp	.+128    	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			else{
				CLEAR_BIT(DDRC,pin_num);
     e16:	a4 e3       	ldi	r26, 0x34	; 52
     e18:	b0 e0       	ldi	r27, 0x00	; 0
     e1a:	e4 e3       	ldi	r30, 0x34	; 52
     e1c:	f0 e0       	ldi	r31, 0x00	; 0
     e1e:	80 81       	ld	r24, Z
     e20:	48 2f       	mov	r20, r24
     e22:	8a 81       	ldd	r24, Y+2	; 0x02
     e24:	28 2f       	mov	r18, r24
     e26:	30 e0       	ldi	r19, 0x00	; 0
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	02 2e       	mov	r0, r18
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <GPIO_setupPinDirection+0x164>
     e30:	88 0f       	add	r24, r24
     e32:	99 1f       	adc	r25, r25
     e34:	0a 94       	dec	r0
     e36:	e2 f7       	brpl	.-8      	; 0xe30 <GPIO_setupPinDirection+0x160>
     e38:	80 95       	com	r24
     e3a:	84 23       	and	r24, r20
     e3c:	8c 93       	st	X, r24
     e3e:	2b c0       	rjmp	.+86     	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT){
     e40:	8b 81       	ldd	r24, Y+3	; 0x03
     e42:	81 30       	cpi	r24, 0x01	; 1
     e44:	a1 f4       	brne	.+40     	; 0xe6e <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD,pin_num);
     e46:	a1 e3       	ldi	r26, 0x31	; 49
     e48:	b0 e0       	ldi	r27, 0x00	; 0
     e4a:	e1 e3       	ldi	r30, 0x31	; 49
     e4c:	f0 e0       	ldi	r31, 0x00	; 0
     e4e:	80 81       	ld	r24, Z
     e50:	48 2f       	mov	r20, r24
     e52:	8a 81       	ldd	r24, Y+2	; 0x02
     e54:	28 2f       	mov	r18, r24
     e56:	30 e0       	ldi	r19, 0x00	; 0
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	02 2e       	mov	r0, r18
     e5e:	02 c0       	rjmp	.+4      	; 0xe64 <GPIO_setupPinDirection+0x194>
     e60:	88 0f       	add	r24, r24
     e62:	99 1f       	adc	r25, r25
     e64:	0a 94       	dec	r0
     e66:	e2 f7       	brpl	.-8      	; 0xe60 <GPIO_setupPinDirection+0x190>
     e68:	84 2b       	or	r24, r20
     e6a:	8c 93       	st	X, r24
     e6c:	14 c0       	rjmp	.+40     	; 0xe96 <GPIO_setupPinDirection+0x1c6>
			}
			else{
				CLEAR_BIT(DDRD,pin_num);
     e6e:	a1 e3       	ldi	r26, 0x31	; 49
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	e1 e3       	ldi	r30, 0x31	; 49
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	80 81       	ld	r24, Z
     e78:	48 2f       	mov	r20, r24
     e7a:	8a 81       	ldd	r24, Y+2	; 0x02
     e7c:	28 2f       	mov	r18, r24
     e7e:	30 e0       	ldi	r19, 0x00	; 0
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	02 2e       	mov	r0, r18
     e86:	02 c0       	rjmp	.+4      	; 0xe8c <GPIO_setupPinDirection+0x1bc>
     e88:	88 0f       	add	r24, r24
     e8a:	99 1f       	adc	r25, r25
     e8c:	0a 94       	dec	r0
     e8e:	e2 f7       	brpl	.-8      	; 0xe88 <GPIO_setupPinDirection+0x1b8>
     e90:	80 95       	com	r24
     e92:	84 23       	and	r24, r20
     e94:	8c 93       	st	X, r24
		}
	}



}
     e96:	0f 90       	pop	r0
     e98:	0f 90       	pop	r0
     e9a:	0f 90       	pop	r0
     e9c:	0f 90       	pop	r0
     e9e:	0f 90       	pop	r0
     ea0:	cf 91       	pop	r28
     ea2:	df 91       	pop	r29
     ea4:	08 95       	ret

00000ea6 <GPIO_writePin>:
 * if the input port number or pin number are not correct \
 * the function will not handle the request.
 * if the pin is input, this function will enable/disable the internal pull \
 * up resistor.
 */
void GPIO_writePin(uint8 port_num , uint8 pin_num ,uint8 value){
     ea6:	df 93       	push	r29
     ea8:	cf 93       	push	r28
     eaa:	00 d0       	rcall	.+0      	; 0xeac <GPIO_writePin+0x6>
     eac:	00 d0       	rcall	.+0      	; 0xeae <GPIO_writePin+0x8>
     eae:	0f 92       	push	r0
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	89 83       	std	Y+1, r24	; 0x01
     eb6:	6a 83       	std	Y+2, r22	; 0x02
     eb8:	4b 83       	std	Y+3, r20	; 0x03
	if((port_num >= NUM_OF_PORTS) || (pin_num >=NUM_OF_PINS)){
     eba:	89 81       	ldd	r24, Y+1	; 0x01
     ebc:	84 30       	cpi	r24, 0x04	; 4
     ebe:	08 f0       	brcs	.+2      	; 0xec2 <GPIO_writePin+0x1c>
     ec0:	d5 c0       	rjmp	.+426    	; 0x106c <GPIO_writePin+0x1c6>
     ec2:	8a 81       	ldd	r24, Y+2	; 0x02
     ec4:	88 30       	cpi	r24, 0x08	; 8
     ec6:	08 f0       	brcs	.+2      	; 0xeca <GPIO_writePin+0x24>
     ec8:	d1 c0       	rjmp	.+418    	; 0x106c <GPIO_writePin+0x1c6>
		/*     Do Nothing     */
	}
	else {
		switch(port_num)   // checking on the port to operate on it
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	28 2f       	mov	r18, r24
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	3d 83       	std	Y+5, r19	; 0x05
     ed2:	2c 83       	std	Y+4, r18	; 0x04
     ed4:	8c 81       	ldd	r24, Y+4	; 0x04
     ed6:	9d 81       	ldd	r25, Y+5	; 0x05
     ed8:	81 30       	cpi	r24, 0x01	; 1
     eda:	91 05       	cpc	r25, r1
     edc:	09 f4       	brne	.+2      	; 0xee0 <GPIO_writePin+0x3a>
     ede:	43 c0       	rjmp	.+134    	; 0xf66 <GPIO_writePin+0xc0>
     ee0:	2c 81       	ldd	r18, Y+4	; 0x04
     ee2:	3d 81       	ldd	r19, Y+5	; 0x05
     ee4:	22 30       	cpi	r18, 0x02	; 2
     ee6:	31 05       	cpc	r19, r1
     ee8:	2c f4       	brge	.+10     	; 0xef4 <GPIO_writePin+0x4e>
     eea:	8c 81       	ldd	r24, Y+4	; 0x04
     eec:	9d 81       	ldd	r25, Y+5	; 0x05
     eee:	00 97       	sbiw	r24, 0x00	; 0
     ef0:	71 f0       	breq	.+28     	; 0xf0e <GPIO_writePin+0x68>
     ef2:	bc c0       	rjmp	.+376    	; 0x106c <GPIO_writePin+0x1c6>
     ef4:	2c 81       	ldd	r18, Y+4	; 0x04
     ef6:	3d 81       	ldd	r19, Y+5	; 0x05
     ef8:	22 30       	cpi	r18, 0x02	; 2
     efa:	31 05       	cpc	r19, r1
     efc:	09 f4       	brne	.+2      	; 0xf00 <GPIO_writePin+0x5a>
     efe:	5f c0       	rjmp	.+190    	; 0xfbe <GPIO_writePin+0x118>
     f00:	8c 81       	ldd	r24, Y+4	; 0x04
     f02:	9d 81       	ldd	r25, Y+5	; 0x05
     f04:	83 30       	cpi	r24, 0x03	; 3
     f06:	91 05       	cpc	r25, r1
     f08:	09 f4       	brne	.+2      	; 0xf0c <GPIO_writePin+0x66>
     f0a:	85 c0       	rjmp	.+266    	; 0x1016 <GPIO_writePin+0x170>
     f0c:	af c0       	rjmp	.+350    	; 0x106c <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH){
     f0e:	8b 81       	ldd	r24, Y+3	; 0x03
     f10:	81 30       	cpi	r24, 0x01	; 1
     f12:	a1 f4       	brne	.+40     	; 0xf3c <GPIO_writePin+0x96>
				SET_BIT(PORTA,pin_num); // setting the required pin to make it output
     f14:	ab e3       	ldi	r26, 0x3B	; 59
     f16:	b0 e0       	ldi	r27, 0x00	; 0
     f18:	eb e3       	ldi	r30, 0x3B	; 59
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	80 81       	ld	r24, Z
     f1e:	48 2f       	mov	r20, r24
     f20:	8a 81       	ldd	r24, Y+2	; 0x02
     f22:	28 2f       	mov	r18, r24
     f24:	30 e0       	ldi	r19, 0x00	; 0
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	02 2e       	mov	r0, r18
     f2c:	02 c0       	rjmp	.+4      	; 0xf32 <GPIO_writePin+0x8c>
     f2e:	88 0f       	add	r24, r24
     f30:	99 1f       	adc	r25, r25
     f32:	0a 94       	dec	r0
     f34:	e2 f7       	brpl	.-8      	; 0xf2e <GPIO_writePin+0x88>
     f36:	84 2b       	or	r24, r20
     f38:	8c 93       	st	X, r24
     f3a:	98 c0       	rjmp	.+304    	; 0x106c <GPIO_writePin+0x1c6>
			}
			else{
				CLEAR_BIT(PORTA,pin_num); // clearing the corresponding bit to make the bit input
     f3c:	ab e3       	ldi	r26, 0x3B	; 59
     f3e:	b0 e0       	ldi	r27, 0x00	; 0
     f40:	eb e3       	ldi	r30, 0x3B	; 59
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	80 81       	ld	r24, Z
     f46:	48 2f       	mov	r20, r24
     f48:	8a 81       	ldd	r24, Y+2	; 0x02
     f4a:	28 2f       	mov	r18, r24
     f4c:	30 e0       	ldi	r19, 0x00	; 0
     f4e:	81 e0       	ldi	r24, 0x01	; 1
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	02 2e       	mov	r0, r18
     f54:	02 c0       	rjmp	.+4      	; 0xf5a <GPIO_writePin+0xb4>
     f56:	88 0f       	add	r24, r24
     f58:	99 1f       	adc	r25, r25
     f5a:	0a 94       	dec	r0
     f5c:	e2 f7       	brpl	.-8      	; 0xf56 <GPIO_writePin+0xb0>
     f5e:	80 95       	com	r24
     f60:	84 23       	and	r24, r20
     f62:	8c 93       	st	X, r24
     f64:	83 c0       	rjmp	.+262    	; 0x106c <GPIO_writePin+0x1c6>
			}
			break;

		case PORTB_ID:
			if(value == LOGIC_HIGH){
     f66:	8b 81       	ldd	r24, Y+3	; 0x03
     f68:	81 30       	cpi	r24, 0x01	; 1
     f6a:	a1 f4       	brne	.+40     	; 0xf94 <GPIO_writePin+0xee>
				SET_BIT(PORTB,pin_num);
     f6c:	a8 e3       	ldi	r26, 0x38	; 56
     f6e:	b0 e0       	ldi	r27, 0x00	; 0
     f70:	e8 e3       	ldi	r30, 0x38	; 56
     f72:	f0 e0       	ldi	r31, 0x00	; 0
     f74:	80 81       	ld	r24, Z
     f76:	48 2f       	mov	r20, r24
     f78:	8a 81       	ldd	r24, Y+2	; 0x02
     f7a:	28 2f       	mov	r18, r24
     f7c:	30 e0       	ldi	r19, 0x00	; 0
     f7e:	81 e0       	ldi	r24, 0x01	; 1
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	02 2e       	mov	r0, r18
     f84:	02 c0       	rjmp	.+4      	; 0xf8a <GPIO_writePin+0xe4>
     f86:	88 0f       	add	r24, r24
     f88:	99 1f       	adc	r25, r25
     f8a:	0a 94       	dec	r0
     f8c:	e2 f7       	brpl	.-8      	; 0xf86 <GPIO_writePin+0xe0>
     f8e:	84 2b       	or	r24, r20
     f90:	8c 93       	st	X, r24
     f92:	6c c0       	rjmp	.+216    	; 0x106c <GPIO_writePin+0x1c6>
			}
			else{
				CLEAR_BIT(PORTB,pin_num);
     f94:	a8 e3       	ldi	r26, 0x38	; 56
     f96:	b0 e0       	ldi	r27, 0x00	; 0
     f98:	e8 e3       	ldi	r30, 0x38	; 56
     f9a:	f0 e0       	ldi	r31, 0x00	; 0
     f9c:	80 81       	ld	r24, Z
     f9e:	48 2f       	mov	r20, r24
     fa0:	8a 81       	ldd	r24, Y+2	; 0x02
     fa2:	28 2f       	mov	r18, r24
     fa4:	30 e0       	ldi	r19, 0x00	; 0
     fa6:	81 e0       	ldi	r24, 0x01	; 1
     fa8:	90 e0       	ldi	r25, 0x00	; 0
     faa:	02 2e       	mov	r0, r18
     fac:	02 c0       	rjmp	.+4      	; 0xfb2 <GPIO_writePin+0x10c>
     fae:	88 0f       	add	r24, r24
     fb0:	99 1f       	adc	r25, r25
     fb2:	0a 94       	dec	r0
     fb4:	e2 f7       	brpl	.-8      	; 0xfae <GPIO_writePin+0x108>
     fb6:	80 95       	com	r24
     fb8:	84 23       	and	r24, r20
     fba:	8c 93       	st	X, r24
     fbc:	57 c0       	rjmp	.+174    	; 0x106c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH){
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
     fc0:	81 30       	cpi	r24, 0x01	; 1
     fc2:	a1 f4       	brne	.+40     	; 0xfec <GPIO_writePin+0x146>
				SET_BIT(PORTC,pin_num);
     fc4:	a5 e3       	ldi	r26, 0x35	; 53
     fc6:	b0 e0       	ldi	r27, 0x00	; 0
     fc8:	e5 e3       	ldi	r30, 0x35	; 53
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 81       	ld	r24, Z
     fce:	48 2f       	mov	r20, r24
     fd0:	8a 81       	ldd	r24, Y+2	; 0x02
     fd2:	28 2f       	mov	r18, r24
     fd4:	30 e0       	ldi	r19, 0x00	; 0
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	02 2e       	mov	r0, r18
     fdc:	02 c0       	rjmp	.+4      	; 0xfe2 <GPIO_writePin+0x13c>
     fde:	88 0f       	add	r24, r24
     fe0:	99 1f       	adc	r25, r25
     fe2:	0a 94       	dec	r0
     fe4:	e2 f7       	brpl	.-8      	; 0xfde <GPIO_writePin+0x138>
     fe6:	84 2b       	or	r24, r20
     fe8:	8c 93       	st	X, r24
     fea:	40 c0       	rjmp	.+128    	; 0x106c <GPIO_writePin+0x1c6>
			}
			else{
				CLEAR_BIT(PORTC,pin_num);
     fec:	a5 e3       	ldi	r26, 0x35	; 53
     fee:	b0 e0       	ldi	r27, 0x00	; 0
     ff0:	e5 e3       	ldi	r30, 0x35	; 53
     ff2:	f0 e0       	ldi	r31, 0x00	; 0
     ff4:	80 81       	ld	r24, Z
     ff6:	48 2f       	mov	r20, r24
     ff8:	8a 81       	ldd	r24, Y+2	; 0x02
     ffa:	28 2f       	mov	r18, r24
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	02 2e       	mov	r0, r18
    1004:	02 c0       	rjmp	.+4      	; 0x100a <GPIO_writePin+0x164>
    1006:	88 0f       	add	r24, r24
    1008:	99 1f       	adc	r25, r25
    100a:	0a 94       	dec	r0
    100c:	e2 f7       	brpl	.-8      	; 0x1006 <GPIO_writePin+0x160>
    100e:	80 95       	com	r24
    1010:	84 23       	and	r24, r20
    1012:	8c 93       	st	X, r24
    1014:	2b c0       	rjmp	.+86     	; 0x106c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH){
    1016:	8b 81       	ldd	r24, Y+3	; 0x03
    1018:	81 30       	cpi	r24, 0x01	; 1
    101a:	a1 f4       	brne	.+40     	; 0x1044 <GPIO_writePin+0x19e>
				SET_BIT(PORTD,pin_num);
    101c:	a2 e3       	ldi	r26, 0x32	; 50
    101e:	b0 e0       	ldi	r27, 0x00	; 0
    1020:	e2 e3       	ldi	r30, 0x32	; 50
    1022:	f0 e0       	ldi	r31, 0x00	; 0
    1024:	80 81       	ld	r24, Z
    1026:	48 2f       	mov	r20, r24
    1028:	8a 81       	ldd	r24, Y+2	; 0x02
    102a:	28 2f       	mov	r18, r24
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	02 2e       	mov	r0, r18
    1034:	02 c0       	rjmp	.+4      	; 0x103a <GPIO_writePin+0x194>
    1036:	88 0f       	add	r24, r24
    1038:	99 1f       	adc	r25, r25
    103a:	0a 94       	dec	r0
    103c:	e2 f7       	brpl	.-8      	; 0x1036 <GPIO_writePin+0x190>
    103e:	84 2b       	or	r24, r20
    1040:	8c 93       	st	X, r24
    1042:	14 c0       	rjmp	.+40     	; 0x106c <GPIO_writePin+0x1c6>
			}
			else{
				CLEAR_BIT(PORTD,pin_num);
    1044:	a2 e3       	ldi	r26, 0x32	; 50
    1046:	b0 e0       	ldi	r27, 0x00	; 0
    1048:	e2 e3       	ldi	r30, 0x32	; 50
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	80 81       	ld	r24, Z
    104e:	48 2f       	mov	r20, r24
    1050:	8a 81       	ldd	r24, Y+2	; 0x02
    1052:	28 2f       	mov	r18, r24
    1054:	30 e0       	ldi	r19, 0x00	; 0
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	02 2e       	mov	r0, r18
    105c:	02 c0       	rjmp	.+4      	; 0x1062 <GPIO_writePin+0x1bc>
    105e:	88 0f       	add	r24, r24
    1060:	99 1f       	adc	r25, r25
    1062:	0a 94       	dec	r0
    1064:	e2 f7       	brpl	.-8      	; 0x105e <GPIO_writePin+0x1b8>
    1066:	80 95       	com	r24
    1068:	84 23       	and	r24, r20
    106a:	8c 93       	st	X, r24
			}
			break;
		}
	}

}
    106c:	0f 90       	pop	r0
    106e:	0f 90       	pop	r0
    1070:	0f 90       	pop	r0
    1072:	0f 90       	pop	r0
    1074:	0f 90       	pop	r0
    1076:	cf 91       	pop	r28
    1078:	df 91       	pop	r29
    107a:	08 95       	ret

0000107c <GPIO_readPin>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num , uint8 pin_num){
    107c:	df 93       	push	r29
    107e:	cf 93       	push	r28
    1080:	00 d0       	rcall	.+0      	; 0x1082 <GPIO_readPin+0x6>
    1082:	00 d0       	rcall	.+0      	; 0x1084 <GPIO_readPin+0x8>
    1084:	0f 92       	push	r0
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
    108a:	89 83       	std	Y+1, r24	; 0x01
    108c:	6a 83       	std	Y+2, r22	; 0x02
	if((port_num >= NUM_OF_PORTS) || (pin_num >=NUM_OF_PINS)){
    108e:	89 81       	ldd	r24, Y+1	; 0x01
    1090:	84 30       	cpi	r24, 0x04	; 4
    1092:	18 f4       	brcc	.+6      	; 0x109a <GPIO_readPin+0x1e>
    1094:	8a 81       	ldd	r24, Y+2	; 0x02
    1096:	88 30       	cpi	r24, 0x08	; 8
    1098:	10 f0       	brcs	.+4      	; 0x109e <GPIO_readPin+0x22>
		return LOGIC_LOW;
    109a:	1d 82       	std	Y+5, r1	; 0x05
    109c:	82 c0       	rjmp	.+260    	; 0x11a2 <GPIO_readPin+0x126>
	}
	else {
		switch(port_num)   // checking on the port to operate on it
    109e:	89 81       	ldd	r24, Y+1	; 0x01
    10a0:	28 2f       	mov	r18, r24
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	3c 83       	std	Y+4, r19	; 0x04
    10a6:	2b 83       	std	Y+3, r18	; 0x03
    10a8:	4b 81       	ldd	r20, Y+3	; 0x03
    10aa:	5c 81       	ldd	r21, Y+4	; 0x04
    10ac:	41 30       	cpi	r20, 0x01	; 1
    10ae:	51 05       	cpc	r21, r1
    10b0:	79 f1       	breq	.+94     	; 0x1110 <GPIO_readPin+0x94>
    10b2:	8b 81       	ldd	r24, Y+3	; 0x03
    10b4:	9c 81       	ldd	r25, Y+4	; 0x04
    10b6:	82 30       	cpi	r24, 0x02	; 2
    10b8:	91 05       	cpc	r25, r1
    10ba:	34 f4       	brge	.+12     	; 0x10c8 <GPIO_readPin+0x4c>
    10bc:	2b 81       	ldd	r18, Y+3	; 0x03
    10be:	3c 81       	ldd	r19, Y+4	; 0x04
    10c0:	21 15       	cp	r18, r1
    10c2:	31 05       	cpc	r19, r1
    10c4:	69 f0       	breq	.+26     	; 0x10e0 <GPIO_readPin+0x64>
    10c6:	6c c0       	rjmp	.+216    	; 0x11a0 <GPIO_readPin+0x124>
    10c8:	4b 81       	ldd	r20, Y+3	; 0x03
    10ca:	5c 81       	ldd	r21, Y+4	; 0x04
    10cc:	42 30       	cpi	r20, 0x02	; 2
    10ce:	51 05       	cpc	r21, r1
    10d0:	b9 f1       	breq	.+110    	; 0x1140 <GPIO_readPin+0xc4>
    10d2:	8b 81       	ldd	r24, Y+3	; 0x03
    10d4:	9c 81       	ldd	r25, Y+4	; 0x04
    10d6:	83 30       	cpi	r24, 0x03	; 3
    10d8:	91 05       	cpc	r25, r1
    10da:	09 f4       	brne	.+2      	; 0x10de <GPIO_readPin+0x62>
    10dc:	49 c0       	rjmp	.+146    	; 0x1170 <GPIO_readPin+0xf4>
    10de:	60 c0       	rjmp	.+192    	; 0x11a0 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num)){
    10e0:	e9 e3       	ldi	r30, 0x39	; 57
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	80 81       	ld	r24, Z
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	8a 81       	ldd	r24, Y+2	; 0x02
    10ec:	88 2f       	mov	r24, r24
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	a9 01       	movw	r20, r18
    10f2:	02 c0       	rjmp	.+4      	; 0x10f8 <GPIO_readPin+0x7c>
    10f4:	55 95       	asr	r21
    10f6:	47 95       	ror	r20
    10f8:	8a 95       	dec	r24
    10fa:	e2 f7       	brpl	.-8      	; 0x10f4 <GPIO_readPin+0x78>
    10fc:	ca 01       	movw	r24, r20
    10fe:	81 70       	andi	r24, 0x01	; 1
    1100:	90 70       	andi	r25, 0x00	; 0
    1102:	88 23       	and	r24, r24
    1104:	19 f0       	breq	.+6      	; 0x110c <GPIO_readPin+0x90>
				return LOGIC_HIGH; // setting the required pin to make it output
    1106:	51 e0       	ldi	r21, 0x01	; 1
    1108:	5d 83       	std	Y+5, r21	; 0x05
    110a:	4b c0       	rjmp	.+150    	; 0x11a2 <GPIO_readPin+0x126>
			}
			else{
				return LOGIC_LOW; // clearing the corresponding bit to make the bit input
    110c:	1d 82       	std	Y+5, r1	; 0x05
    110e:	49 c0       	rjmp	.+146    	; 0x11a2 <GPIO_readPin+0x126>
			}
			break;

		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num)){
    1110:	e6 e3       	ldi	r30, 0x36	; 54
    1112:	f0 e0       	ldi	r31, 0x00	; 0
    1114:	80 81       	ld	r24, Z
    1116:	28 2f       	mov	r18, r24
    1118:	30 e0       	ldi	r19, 0x00	; 0
    111a:	8a 81       	ldd	r24, Y+2	; 0x02
    111c:	88 2f       	mov	r24, r24
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	a9 01       	movw	r20, r18
    1122:	02 c0       	rjmp	.+4      	; 0x1128 <GPIO_readPin+0xac>
    1124:	55 95       	asr	r21
    1126:	47 95       	ror	r20
    1128:	8a 95       	dec	r24
    112a:	e2 f7       	brpl	.-8      	; 0x1124 <GPIO_readPin+0xa8>
    112c:	ca 01       	movw	r24, r20
    112e:	81 70       	andi	r24, 0x01	; 1
    1130:	90 70       	andi	r25, 0x00	; 0
    1132:	88 23       	and	r24, r24
    1134:	19 f0       	breq	.+6      	; 0x113c <GPIO_readPin+0xc0>
				return LOGIC_HIGH;
    1136:	51 e0       	ldi	r21, 0x01	; 1
    1138:	5d 83       	std	Y+5, r21	; 0x05
    113a:	33 c0       	rjmp	.+102    	; 0x11a2 <GPIO_readPin+0x126>
			}
			else{
				return LOGIC_LOW;
    113c:	1d 82       	std	Y+5, r1	; 0x05
    113e:	31 c0       	rjmp	.+98     	; 0x11a2 <GPIO_readPin+0x126>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num)){
    1140:	e3 e3       	ldi	r30, 0x33	; 51
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	28 2f       	mov	r18, r24
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	8a 81       	ldd	r24, Y+2	; 0x02
    114c:	88 2f       	mov	r24, r24
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	a9 01       	movw	r20, r18
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <GPIO_readPin+0xdc>
    1154:	55 95       	asr	r21
    1156:	47 95       	ror	r20
    1158:	8a 95       	dec	r24
    115a:	e2 f7       	brpl	.-8      	; 0x1154 <GPIO_readPin+0xd8>
    115c:	ca 01       	movw	r24, r20
    115e:	81 70       	andi	r24, 0x01	; 1
    1160:	90 70       	andi	r25, 0x00	; 0
    1162:	88 23       	and	r24, r24
    1164:	19 f0       	breq	.+6      	; 0x116c <GPIO_readPin+0xf0>
				return LOGIC_HIGH;
    1166:	51 e0       	ldi	r21, 0x01	; 1
    1168:	5d 83       	std	Y+5, r21	; 0x05
    116a:	1b c0       	rjmp	.+54     	; 0x11a2 <GPIO_readPin+0x126>
			}
			else{
				return LOGIC_LOW;
    116c:	1d 82       	std	Y+5, r1	; 0x05
    116e:	19 c0       	rjmp	.+50     	; 0x11a2 <GPIO_readPin+0x126>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num)){
    1170:	e0 e3       	ldi	r30, 0x30	; 48
    1172:	f0 e0       	ldi	r31, 0x00	; 0
    1174:	80 81       	ld	r24, Z
    1176:	28 2f       	mov	r18, r24
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	8a 81       	ldd	r24, Y+2	; 0x02
    117c:	88 2f       	mov	r24, r24
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	a9 01       	movw	r20, r18
    1182:	02 c0       	rjmp	.+4      	; 0x1188 <GPIO_readPin+0x10c>
    1184:	55 95       	asr	r21
    1186:	47 95       	ror	r20
    1188:	8a 95       	dec	r24
    118a:	e2 f7       	brpl	.-8      	; 0x1184 <GPIO_readPin+0x108>
    118c:	ca 01       	movw	r24, r20
    118e:	81 70       	andi	r24, 0x01	; 1
    1190:	90 70       	andi	r25, 0x00	; 0
    1192:	88 23       	and	r24, r24
    1194:	19 f0       	breq	.+6      	; 0x119c <GPIO_readPin+0x120>
				return LOGIC_HIGH;
    1196:	51 e0       	ldi	r21, 0x01	; 1
    1198:	5d 83       	std	Y+5, r21	; 0x05
    119a:	03 c0       	rjmp	.+6      	; 0x11a2 <GPIO_readPin+0x126>
			}
			else{
				return LOGIC_LOW;
    119c:	1d 82       	std	Y+5, r1	; 0x05
    119e:	01 c0       	rjmp	.+2      	; 0x11a2 <GPIO_readPin+0x126>
			break;
		}


	}
	return LOGIC_LOW ;
    11a0:	1d 82       	std	Y+5, r1	; 0x05
    11a2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	0f 90       	pop	r0
    11ae:	cf 91       	pop	r28
    11b0:	df 91       	pop	r29
    11b2:	08 95       	ret

000011b4 <GPIO_setupPortDirection>:
 * Setup the direction of the required port all pins input/output.
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num ,GPIO_PortDirectionType direction){
    11b4:	df 93       	push	r29
    11b6:	cf 93       	push	r28
    11b8:	00 d0       	rcall	.+0      	; 0x11ba <GPIO_setupPortDirection+0x6>
    11ba:	00 d0       	rcall	.+0      	; 0x11bc <GPIO_setupPortDirection+0x8>
    11bc:	cd b7       	in	r28, 0x3d	; 61
    11be:	de b7       	in	r29, 0x3e	; 62
    11c0:	89 83       	std	Y+1, r24	; 0x01
    11c2:	6a 83       	std	Y+2, r22	; 0x02
	if(port_num >= NUM_OF_PORTS){
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	84 30       	cpi	r24, 0x04	; 4
    11c8:	90 f5       	brcc	.+100    	; 0x122e <GPIO_setupPortDirection+0x7a>
		/*     Do Nothing     */
	}
	else {
		switch(port_num)   // checking on the port to operate on it
    11ca:	89 81       	ldd	r24, Y+1	; 0x01
    11cc:	28 2f       	mov	r18, r24
    11ce:	30 e0       	ldi	r19, 0x00	; 0
    11d0:	3c 83       	std	Y+4, r19	; 0x04
    11d2:	2b 83       	std	Y+3, r18	; 0x03
    11d4:	8b 81       	ldd	r24, Y+3	; 0x03
    11d6:	9c 81       	ldd	r25, Y+4	; 0x04
    11d8:	81 30       	cpi	r24, 0x01	; 1
    11da:	91 05       	cpc	r25, r1
    11dc:	d1 f0       	breq	.+52     	; 0x1212 <GPIO_setupPortDirection+0x5e>
    11de:	2b 81       	ldd	r18, Y+3	; 0x03
    11e0:	3c 81       	ldd	r19, Y+4	; 0x04
    11e2:	22 30       	cpi	r18, 0x02	; 2
    11e4:	31 05       	cpc	r19, r1
    11e6:	2c f4       	brge	.+10     	; 0x11f2 <GPIO_setupPortDirection+0x3e>
    11e8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ea:	9c 81       	ldd	r25, Y+4	; 0x04
    11ec:	00 97       	sbiw	r24, 0x00	; 0
    11ee:	61 f0       	breq	.+24     	; 0x1208 <GPIO_setupPortDirection+0x54>
    11f0:	1e c0       	rjmp	.+60     	; 0x122e <GPIO_setupPortDirection+0x7a>
    11f2:	2b 81       	ldd	r18, Y+3	; 0x03
    11f4:	3c 81       	ldd	r19, Y+4	; 0x04
    11f6:	22 30       	cpi	r18, 0x02	; 2
    11f8:	31 05       	cpc	r19, r1
    11fa:	81 f0       	breq	.+32     	; 0x121c <GPIO_setupPortDirection+0x68>
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1200:	83 30       	cpi	r24, 0x03	; 3
    1202:	91 05       	cpc	r25, r1
    1204:	81 f0       	breq	.+32     	; 0x1226 <GPIO_setupPortDirection+0x72>
    1206:	13 c0       	rjmp	.+38     	; 0x122e <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA =direction;
    1208:	ea e3       	ldi	r30, 0x3A	; 58
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	80 83       	st	Z, r24
    1210:	0e c0       	rjmp	.+28     	; 0x122e <GPIO_setupPortDirection+0x7a>
			break;

		case PORTB_ID:
			DDRB = direction;
    1212:	e7 e3       	ldi	r30, 0x37	; 55
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	8a 81       	ldd	r24, Y+2	; 0x02
    1218:	80 83       	st	Z, r24
    121a:	09 c0       	rjmp	.+18     	; 0x122e <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    121c:	e4 e3       	ldi	r30, 0x34	; 52
    121e:	f0 e0       	ldi	r31, 0x00	; 0
    1220:	8a 81       	ldd	r24, Y+2	; 0x02
    1222:	80 83       	st	Z, r24
    1224:	04 c0       	rjmp	.+8      	; 0x122e <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD =direction ;
    1226:	e1 e3       	ldi	r30, 0x31	; 49
    1228:	f0 e0       	ldi	r31, 0x00	; 0
    122a:	8a 81       	ldd	r24, Y+2	; 0x02
    122c:	80 83       	st	Z, r24
			break;
		}
	}
}
    122e:	0f 90       	pop	r0
    1230:	0f 90       	pop	r0
    1232:	0f 90       	pop	r0
    1234:	0f 90       	pop	r0
    1236:	cf 91       	pop	r28
    1238:	df 91       	pop	r29
    123a:	08 95       	ret

0000123c <GPIO_writePort>:
 * Write the value on the required port.
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num ,uint8 value){
    123c:	df 93       	push	r29
    123e:	cf 93       	push	r28
    1240:	00 d0       	rcall	.+0      	; 0x1242 <GPIO_writePort+0x6>
    1242:	00 d0       	rcall	.+0      	; 0x1244 <GPIO_writePort+0x8>
    1244:	cd b7       	in	r28, 0x3d	; 61
    1246:	de b7       	in	r29, 0x3e	; 62
    1248:	89 83       	std	Y+1, r24	; 0x01
    124a:	6a 83       	std	Y+2, r22	; 0x02
	if(port_num >= NUM_OF_PORTS){
    124c:	89 81       	ldd	r24, Y+1	; 0x01
    124e:	84 30       	cpi	r24, 0x04	; 4
    1250:	90 f5       	brcc	.+100    	; 0x12b6 <GPIO_writePort+0x7a>
		/*     Do Nothing     */
	}
	else {
		switch(port_num)   //  checking on the port to operate on it
    1252:	89 81       	ldd	r24, Y+1	; 0x01
    1254:	28 2f       	mov	r18, r24
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	3c 83       	std	Y+4, r19	; 0x04
    125a:	2b 83       	std	Y+3, r18	; 0x03
    125c:	8b 81       	ldd	r24, Y+3	; 0x03
    125e:	9c 81       	ldd	r25, Y+4	; 0x04
    1260:	81 30       	cpi	r24, 0x01	; 1
    1262:	91 05       	cpc	r25, r1
    1264:	d1 f0       	breq	.+52     	; 0x129a <GPIO_writePort+0x5e>
    1266:	2b 81       	ldd	r18, Y+3	; 0x03
    1268:	3c 81       	ldd	r19, Y+4	; 0x04
    126a:	22 30       	cpi	r18, 0x02	; 2
    126c:	31 05       	cpc	r19, r1
    126e:	2c f4       	brge	.+10     	; 0x127a <GPIO_writePort+0x3e>
    1270:	8b 81       	ldd	r24, Y+3	; 0x03
    1272:	9c 81       	ldd	r25, Y+4	; 0x04
    1274:	00 97       	sbiw	r24, 0x00	; 0
    1276:	61 f0       	breq	.+24     	; 0x1290 <GPIO_writePort+0x54>
    1278:	1e c0       	rjmp	.+60     	; 0x12b6 <GPIO_writePort+0x7a>
    127a:	2b 81       	ldd	r18, Y+3	; 0x03
    127c:	3c 81       	ldd	r19, Y+4	; 0x04
    127e:	22 30       	cpi	r18, 0x02	; 2
    1280:	31 05       	cpc	r19, r1
    1282:	81 f0       	breq	.+32     	; 0x12a4 <GPIO_writePort+0x68>
    1284:	8b 81       	ldd	r24, Y+3	; 0x03
    1286:	9c 81       	ldd	r25, Y+4	; 0x04
    1288:	83 30       	cpi	r24, 0x03	; 3
    128a:	91 05       	cpc	r25, r1
    128c:	81 f0       	breq	.+32     	; 0x12ae <GPIO_writePort+0x72>
    128e:	13 c0       	rjmp	.+38     	; 0x12b6 <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    1290:	eb e3       	ldi	r30, 0x3B	; 59
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	8a 81       	ldd	r24, Y+2	; 0x02
    1296:	80 83       	st	Z, r24
    1298:	0e c0       	rjmp	.+28     	; 0x12b6 <GPIO_writePort+0x7a>
			break;

		case PORTB_ID:
			PORTB = value;
    129a:	e8 e3       	ldi	r30, 0x38	; 56
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	80 83       	st	Z, r24
    12a2:	09 c0       	rjmp	.+18     	; 0x12b6 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    12a4:	e5 e3       	ldi	r30, 0x35	; 53
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	8a 81       	ldd	r24, Y+2	; 0x02
    12aa:	80 83       	st	Z, r24
    12ac:	04 c0       	rjmp	.+8      	; 0x12b6 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    12ae:	e2 e3       	ldi	r30, 0x32	; 50
    12b0:	f0 e0       	ldi	r31, 0x00	; 0
    12b2:	8a 81       	ldd	r24, Y+2	; 0x02
    12b4:	80 83       	st	Z, r24
			break;
		}
	}


}
    12b6:	0f 90       	pop	r0
    12b8:	0f 90       	pop	r0
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	cf 91       	pop	r28
    12c0:	df 91       	pop	r29
    12c2:	08 95       	ret

000012c4 <GPIO_readPort>:
/*
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num){
    12c4:	df 93       	push	r29
    12c6:	cf 93       	push	r28
    12c8:	00 d0       	rcall	.+0      	; 0x12ca <GPIO_readPort+0x6>
    12ca:	00 d0       	rcall	.+0      	; 0x12cc <GPIO_readPort+0x8>
    12cc:	cd b7       	in	r28, 0x3d	; 61
    12ce:	de b7       	in	r29, 0x3e	; 62
    12d0:	89 83       	std	Y+1, r24	; 0x01
	if(port_num >= NUM_OF_PORTS){
    12d2:	89 81       	ldd	r24, Y+1	; 0x01
    12d4:	84 30       	cpi	r24, 0x04	; 4
    12d6:	10 f0       	brcs	.+4      	; 0x12dc <GPIO_readPort+0x18>
		return 0;
    12d8:	1c 82       	std	Y+4, r1	; 0x04
    12da:	34 c0       	rjmp	.+104    	; 0x1344 <GPIO_readPort+0x80>
	}
	else {
		switch(port_num)   //  checking on the port to operate on it
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	28 2f       	mov	r18, r24
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	3b 83       	std	Y+3, r19	; 0x03
    12e4:	2a 83       	std	Y+2, r18	; 0x02
    12e6:	8a 81       	ldd	r24, Y+2	; 0x02
    12e8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ea:	81 30       	cpi	r24, 0x01	; 1
    12ec:	91 05       	cpc	r25, r1
    12ee:	d1 f0       	breq	.+52     	; 0x1324 <GPIO_readPort+0x60>
    12f0:	2a 81       	ldd	r18, Y+2	; 0x02
    12f2:	3b 81       	ldd	r19, Y+3	; 0x03
    12f4:	22 30       	cpi	r18, 0x02	; 2
    12f6:	31 05       	cpc	r19, r1
    12f8:	2c f4       	brge	.+10     	; 0x1304 <GPIO_readPort+0x40>
    12fa:	8a 81       	ldd	r24, Y+2	; 0x02
    12fc:	9b 81       	ldd	r25, Y+3	; 0x03
    12fe:	00 97       	sbiw	r24, 0x00	; 0
    1300:	61 f0       	breq	.+24     	; 0x131a <GPIO_readPort+0x56>
    1302:	1f c0       	rjmp	.+62     	; 0x1342 <GPIO_readPort+0x7e>
    1304:	2a 81       	ldd	r18, Y+2	; 0x02
    1306:	3b 81       	ldd	r19, Y+3	; 0x03
    1308:	22 30       	cpi	r18, 0x02	; 2
    130a:	31 05       	cpc	r19, r1
    130c:	81 f0       	breq	.+32     	; 0x132e <GPIO_readPort+0x6a>
    130e:	8a 81       	ldd	r24, Y+2	; 0x02
    1310:	9b 81       	ldd	r25, Y+3	; 0x03
    1312:	83 30       	cpi	r24, 0x03	; 3
    1314:	91 05       	cpc	r25, r1
    1316:	81 f0       	breq	.+32     	; 0x1338 <GPIO_readPort+0x74>
    1318:	14 c0       	rjmp	.+40     	; 0x1342 <GPIO_readPort+0x7e>
		{
		case PORTA_ID:
			return PINA;
    131a:	e9 e3       	ldi	r30, 0x39	; 57
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	90 81       	ld	r25, Z
    1320:	9c 83       	std	Y+4, r25	; 0x04
    1322:	10 c0       	rjmp	.+32     	; 0x1344 <GPIO_readPort+0x80>
		case PORTB_ID:
			return PINB;
    1324:	e6 e3       	ldi	r30, 0x36	; 54
    1326:	f0 e0       	ldi	r31, 0x00	; 0
    1328:	20 81       	ld	r18, Z
    132a:	2c 83       	std	Y+4, r18	; 0x04
    132c:	0b c0       	rjmp	.+22     	; 0x1344 <GPIO_readPort+0x80>
		case PORTC_ID:
			return PINC;
    132e:	e3 e3       	ldi	r30, 0x33	; 51
    1330:	f0 e0       	ldi	r31, 0x00	; 0
    1332:	30 81       	ld	r19, Z
    1334:	3c 83       	std	Y+4, r19	; 0x04
    1336:	06 c0       	rjmp	.+12     	; 0x1344 <GPIO_readPort+0x80>
		case PORTD_ID:
			return PIND;
    1338:	e0 e3       	ldi	r30, 0x30	; 48
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	80 81       	ld	r24, Z
    133e:	8c 83       	std	Y+4, r24	; 0x04
    1340:	01 c0       	rjmp	.+2      	; 0x1344 <GPIO_readPort+0x80>
		}
	}
	return 0;
    1342:	1c 82       	std	Y+4, r1	; 0x04
    1344:	8c 81       	ldd	r24, Y+4	; 0x04



}
    1346:	0f 90       	pop	r0
    1348:	0f 90       	pop	r0
    134a:	0f 90       	pop	r0
    134c:	0f 90       	pop	r0
    134e:	cf 91       	pop	r28
    1350:	df 91       	pop	r29
    1352:	08 95       	ret

00001354 <main>:
 * entered the password incorrectly for three consecutive times
 */
void handle_error(void);

int main(void)
{
    1354:	df 93       	push	r29
    1356:	cf 93       	push	r28
    1358:	cd b7       	in	r28, 0x3d	; 61
    135a:	de b7       	in	r29, 0x3e	; 62
    135c:	60 97       	sbiw	r28, 0x10	; 16
    135e:	0f b6       	in	r0, 0x3f	; 63
    1360:	f8 94       	cli
    1362:	de bf       	out	0x3e, r29	; 62
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	cd bf       	out	0x3d, r28	; 61
	SREG |=(1<<7);  // enable global interrupt
    1368:	af e5       	ldi	r26, 0x5F	; 95
    136a:	b0 e0       	ldi	r27, 0x00	; 0
    136c:	ef e5       	ldi	r30, 0x5F	; 95
    136e:	f0 e0       	ldi	r31, 0x00	; 0
    1370:	80 81       	ld	r24, Z
    1372:	80 68       	ori	r24, 0x80	; 128
    1374:	8c 93       	st	X, r24
	 * data bits = eight bits
	 * parity is even
	 * one stop bit mode
	 * baud rate = 9600
	 */
	UART_ConfigType uart_configuration={EIGHT_BITS , EVEN ,ONE_BIT ,9600};
    1376:	ce 01       	movw	r24, r28
    1378:	03 96       	adiw	r24, 0x03	; 3
    137a:	9d 87       	std	Y+13, r25	; 0x0d
    137c:	8c 87       	std	Y+12, r24	; 0x0c
    137e:	e8 e6       	ldi	r30, 0x68	; 104
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	ff 87       	std	Y+15, r31	; 0x0f
    1384:	ee 87       	std	Y+14, r30	; 0x0e
    1386:	f7 e0       	ldi	r31, 0x07	; 7
    1388:	f8 8b       	std	Y+16, r31	; 0x10
    138a:	ee 85       	ldd	r30, Y+14	; 0x0e
    138c:	ff 85       	ldd	r31, Y+15	; 0x0f
    138e:	00 80       	ld	r0, Z
    1390:	8e 85       	ldd	r24, Y+14	; 0x0e
    1392:	9f 85       	ldd	r25, Y+15	; 0x0f
    1394:	01 96       	adiw	r24, 0x01	; 1
    1396:	9f 87       	std	Y+15, r25	; 0x0f
    1398:	8e 87       	std	Y+14, r24	; 0x0e
    139a:	ec 85       	ldd	r30, Y+12	; 0x0c
    139c:	fd 85       	ldd	r31, Y+13	; 0x0d
    139e:	00 82       	st	Z, r0
    13a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    13a4:	01 96       	adiw	r24, 0x01	; 1
    13a6:	9d 87       	std	Y+13, r25	; 0x0d
    13a8:	8c 87       	std	Y+12, r24	; 0x0c
    13aa:	98 89       	ldd	r25, Y+16	; 0x10
    13ac:	91 50       	subi	r25, 0x01	; 1
    13ae:	98 8b       	std	Y+16, r25	; 0x10
    13b0:	e8 89       	ldd	r30, Y+16	; 0x10
    13b2:	ee 23       	and	r30, r30
    13b4:	51 f7       	brne	.-44     	; 0x138a <main+0x36>

	/*
	 * initialize the UART communication
	 */
	UART_init(&uart_configuration);
    13b6:	ce 01       	movw	r24, r28
    13b8:	03 96       	adiw	r24, 0x03	; 3
    13ba:	0e 94 0b 10 	call	0x2016	; 0x2016 <UART_init>
	 * address =10
	 * TWBR =2 to make the baud rate = 400kbps
	 *
	 *
	 */
	TWI_ConfigType I2C_configuration ={10,2};
    13be:	8a e0       	ldi	r24, 0x0A	; 10
    13c0:	8a 87       	std	Y+10, r24	; 0x0a
    13c2:	82 e0       	ldi	r24, 0x02	; 2
    13c4:	8b 87       	std	Y+11, r24	; 0x0b
	/*
	 * initialize the I2C communication
	 */
	TWI_init(&I2C_configuration);
    13c6:	ce 01       	movw	r24, r28
    13c8:	0a 96       	adiw	r24, 0x0a	; 10
    13ca:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <TWI_init>

	/*
	 * initialize the motor
	 */
	DcMotor_Init();
    13ce:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <DcMotor_Init>
	/*
	 * let the user creates the password and save it in the EEPROM
	 */
	Buzzer_init();
    13d2:	0e 94 a3 05 	call	0xb46	; 0xb46 <Buzzer_init>


	create_password();
    13d6:	0e 94 47 0a 	call	0x148e	; 0x148e <create_password>
	uint8 count=0;
    13da:	1a 82       	std	Y+2, r1	; 0x02
	boolean result;

	while (1){
		result=do_action();
    13dc:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <do_action>
    13e0:	89 83       	std	Y+1, r24	; 0x01
		if(result){
    13e2:	89 81       	ldd	r24, Y+1	; 0x01
    13e4:	88 23       	and	r24, r24
    13e6:	11 f0       	breq	.+4      	; 0x13ec <main+0x98>
			count=0;
    13e8:	1a 82       	std	Y+2, r1	; 0x02
    13ea:	03 c0       	rjmp	.+6      	; 0x13f2 <main+0x9e>
		}
		else{
			count++;
    13ec:	8a 81       	ldd	r24, Y+2	; 0x02
    13ee:	8f 5f       	subi	r24, 0xFF	; 255
    13f0:	8a 83       	std	Y+2, r24	; 0x02
		}
		if (count==3){
    13f2:	8a 81       	ldd	r24, Y+2	; 0x02
    13f4:	83 30       	cpi	r24, 0x03	; 3
    13f6:	91 f7       	brne	.-28     	; 0x13dc <main+0x88>
			handle_error();
    13f8:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <handle_error>
    13fc:	ef cf       	rjmp	.-34     	; 0x13dc <main+0x88>

000013fe <check_password>:



}

boolean check_password(uint8 * pass1 , uint8 * pass2){
    13fe:	df 93       	push	r29
    1400:	cf 93       	push	r28
    1402:	00 d0       	rcall	.+0      	; 0x1404 <check_password+0x6>
    1404:	00 d0       	rcall	.+0      	; 0x1406 <check_password+0x8>
    1406:	00 d0       	rcall	.+0      	; 0x1408 <check_password+0xa>
    1408:	cd b7       	in	r28, 0x3d	; 61
    140a:	de b7       	in	r29, 0x3e	; 62
    140c:	9b 83       	std	Y+3, r25	; 0x03
    140e:	8a 83       	std	Y+2, r24	; 0x02
    1410:	7d 83       	std	Y+5, r23	; 0x05
    1412:	6c 83       	std	Y+4, r22	; 0x04
	uint8 i =0 ;
    1414:	19 82       	std	Y+1, r1	; 0x01
    1416:	19 c0       	rjmp	.+50     	; 0x144a <check_password+0x4c>
	while (pass1[i] != '\0' && pass2[i]!= '\0' ){
		if (pass1[i] != pass2[i]){
    1418:	89 81       	ldd	r24, Y+1	; 0x01
    141a:	28 2f       	mov	r18, r24
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	8a 81       	ldd	r24, Y+2	; 0x02
    1420:	9b 81       	ldd	r25, Y+3	; 0x03
    1422:	fc 01       	movw	r30, r24
    1424:	e2 0f       	add	r30, r18
    1426:	f3 1f       	adc	r31, r19
    1428:	40 81       	ld	r20, Z
    142a:	89 81       	ldd	r24, Y+1	; 0x01
    142c:	28 2f       	mov	r18, r24
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	8c 81       	ldd	r24, Y+4	; 0x04
    1432:	9d 81       	ldd	r25, Y+5	; 0x05
    1434:	fc 01       	movw	r30, r24
    1436:	e2 0f       	add	r30, r18
    1438:	f3 1f       	adc	r31, r19
    143a:	80 81       	ld	r24, Z
    143c:	48 17       	cp	r20, r24
    143e:	11 f0       	breq	.+4      	; 0x1444 <check_password+0x46>
			return FALSE;
    1440:	1e 82       	std	Y+6, r1	; 0x06
    1442:	1b c0       	rjmp	.+54     	; 0x147a <check_password+0x7c>
		}
		i++;
    1444:	89 81       	ldd	r24, Y+1	; 0x01
    1446:	8f 5f       	subi	r24, 0xFF	; 255
    1448:	89 83       	std	Y+1, r24	; 0x01

}

boolean check_password(uint8 * pass1 , uint8 * pass2){
	uint8 i =0 ;
	while (pass1[i] != '\0' && pass2[i]!= '\0' ){
    144a:	89 81       	ldd	r24, Y+1	; 0x01
    144c:	28 2f       	mov	r18, r24
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	9b 81       	ldd	r25, Y+3	; 0x03
    1454:	fc 01       	movw	r30, r24
    1456:	e2 0f       	add	r30, r18
    1458:	f3 1f       	adc	r31, r19
    145a:	80 81       	ld	r24, Z
    145c:	88 23       	and	r24, r24
    145e:	59 f0       	breq	.+22     	; 0x1476 <check_password+0x78>
    1460:	89 81       	ldd	r24, Y+1	; 0x01
    1462:	28 2f       	mov	r18, r24
    1464:	30 e0       	ldi	r19, 0x00	; 0
    1466:	8c 81       	ldd	r24, Y+4	; 0x04
    1468:	9d 81       	ldd	r25, Y+5	; 0x05
    146a:	fc 01       	movw	r30, r24
    146c:	e2 0f       	add	r30, r18
    146e:	f3 1f       	adc	r31, r19
    1470:	80 81       	ld	r24, Z
    1472:	88 23       	and	r24, r24
    1474:	89 f6       	brne	.-94     	; 0x1418 <check_password+0x1a>
		if (pass1[i] != pass2[i]){
			return FALSE;
		}
		i++;
	}
	return TRUE;
    1476:	81 e0       	ldi	r24, 0x01	; 1
    1478:	8e 83       	std	Y+6, r24	; 0x06
    147a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    147c:	26 96       	adiw	r28, 0x06	; 6
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	de bf       	out	0x3e, r29	; 62
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	cd bf       	out	0x3d, r28	; 61
    1488:	cf 91       	pop	r28
    148a:	df 91       	pop	r29
    148c:	08 95       	ret

0000148e <create_password>:

void create_password(void){
    148e:	df 93       	push	r29
    1490:	cf 93       	push	r28
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	6c 97       	sbiw	r28, 0x1c	; 28
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
	//flag to be raised when finishing the password
	boolean finish_password = FALSE;
    14a2:	18 8a       	std	Y+16, r1	; 0x10
    14a4:	94 c0       	rjmp	.+296    	; 0x15ce <create_password+0x140>
	uint8 created_password [6];
	uint8 confirming_password[6];
	uint8 result;


	while(finish_password == FALSE){
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	aa ef       	ldi	r26, 0xFA	; 250
    14ac:	b3 e4       	ldi	r27, 0x43	; 67
    14ae:	8b 87       	std	Y+11, r24	; 0x0b
    14b0:	9c 87       	std	Y+12, r25	; 0x0c
    14b2:	ad 87       	std	Y+13, r26	; 0x0d
    14b4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    14b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    14b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    14ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    14bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    14be:	20 e0       	ldi	r18, 0x00	; 0
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	4a ef       	ldi	r20, 0xFA	; 250
    14c4:	54 e4       	ldi	r21, 0x44	; 68
    14c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14ca:	dc 01       	movw	r26, r24
    14cc:	cb 01       	movw	r24, r22
    14ce:	8f 83       	std	Y+7, r24	; 0x07
    14d0:	98 87       	std	Y+8, r25	; 0x08
    14d2:	a9 87       	std	Y+9, r26	; 0x09
    14d4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    14d6:	6f 81       	ldd	r22, Y+7	; 0x07
    14d8:	78 85       	ldd	r23, Y+8	; 0x08
    14da:	89 85       	ldd	r24, Y+9	; 0x09
    14dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    14de:	20 e0       	ldi	r18, 0x00	; 0
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	40 e8       	ldi	r20, 0x80	; 128
    14e4:	5f e3       	ldi	r21, 0x3F	; 63
    14e6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    14ea:	88 23       	and	r24, r24
    14ec:	2c f4       	brge	.+10     	; 0x14f8 <create_password+0x6a>
		__ticks = 1;
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	9e 83       	std	Y+6, r25	; 0x06
    14f4:	8d 83       	std	Y+5, r24	; 0x05
    14f6:	3f c0       	rjmp	.+126    	; 0x1576 <create_password+0xe8>
	else if (__tmp > 65535)
    14f8:	6f 81       	ldd	r22, Y+7	; 0x07
    14fa:	78 85       	ldd	r23, Y+8	; 0x08
    14fc:	89 85       	ldd	r24, Y+9	; 0x09
    14fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1500:	20 e0       	ldi	r18, 0x00	; 0
    1502:	3f ef       	ldi	r19, 0xFF	; 255
    1504:	4f e7       	ldi	r20, 0x7F	; 127
    1506:	57 e4       	ldi	r21, 0x47	; 71
    1508:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    150c:	18 16       	cp	r1, r24
    150e:	4c f5       	brge	.+82     	; 0x1562 <create_password+0xd4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1510:	6b 85       	ldd	r22, Y+11	; 0x0b
    1512:	7c 85       	ldd	r23, Y+12	; 0x0c
    1514:	8d 85       	ldd	r24, Y+13	; 0x0d
    1516:	9e 85       	ldd	r25, Y+14	; 0x0e
    1518:	20 e0       	ldi	r18, 0x00	; 0
    151a:	30 e0       	ldi	r19, 0x00	; 0
    151c:	40 e2       	ldi	r20, 0x20	; 32
    151e:	51 e4       	ldi	r21, 0x41	; 65
    1520:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1524:	dc 01       	movw	r26, r24
    1526:	cb 01       	movw	r24, r22
    1528:	bc 01       	movw	r22, r24
    152a:	cd 01       	movw	r24, r26
    152c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1530:	dc 01       	movw	r26, r24
    1532:	cb 01       	movw	r24, r22
    1534:	9e 83       	std	Y+6, r25	; 0x06
    1536:	8d 83       	std	Y+5, r24	; 0x05
    1538:	0f c0       	rjmp	.+30     	; 0x1558 <create_password+0xca>
    153a:	88 ec       	ldi	r24, 0xC8	; 200
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	9c 83       	std	Y+4, r25	; 0x04
    1540:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	f1 f7       	brne	.-4      	; 0x1546 <create_password+0xb8>
    154a:	9c 83       	std	Y+4, r25	; 0x04
    154c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    154e:	8d 81       	ldd	r24, Y+5	; 0x05
    1550:	9e 81       	ldd	r25, Y+6	; 0x06
    1552:	01 97       	sbiw	r24, 0x01	; 1
    1554:	9e 83       	std	Y+6, r25	; 0x06
    1556:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1558:	8d 81       	ldd	r24, Y+5	; 0x05
    155a:	9e 81       	ldd	r25, Y+6	; 0x06
    155c:	00 97       	sbiw	r24, 0x00	; 0
    155e:	69 f7       	brne	.-38     	; 0x153a <create_password+0xac>
    1560:	14 c0       	rjmp	.+40     	; 0x158a <create_password+0xfc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1562:	6f 81       	ldd	r22, Y+7	; 0x07
    1564:	78 85       	ldd	r23, Y+8	; 0x08
    1566:	89 85       	ldd	r24, Y+9	; 0x09
    1568:	9a 85       	ldd	r25, Y+10	; 0x0a
    156a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    156e:	dc 01       	movw	r26, r24
    1570:	cb 01       	movw	r24, r22
    1572:	9e 83       	std	Y+6, r25	; 0x06
    1574:	8d 83       	std	Y+5, r24	; 0x05
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	9e 81       	ldd	r25, Y+6	; 0x06
    157a:	9a 83       	std	Y+2, r25	; 0x02
    157c:	89 83       	std	Y+1, r24	; 0x01
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	9a 81       	ldd	r25, Y+2	; 0x02
    1582:	01 97       	sbiw	r24, 0x01	; 1
    1584:	f1 f7       	brne	.-4      	; 0x1582 <create_password+0xf4>
    1586:	9a 83       	std	Y+2, r25	; 0x02
    1588:	89 83       	std	Y+1, r24	; 0x01
		// send a byte to tell the other controller that this controller is ready
		_delay_ms(500);
		UART_sendByte(MC2_READY);
    158a:	80 e1       	ldi	r24, 0x10	; 16
    158c:	0e 94 b0 10 	call	0x2160	; 0x2160 <UART_sendByte>
		// receive the pass
		UART_receiveString(created_password);
    1590:	ce 01       	movw	r24, r28
    1592:	41 96       	adiw	r24, 0x11	; 17
    1594:	0e 94 ff 10 	call	0x21fe	; 0x21fe <UART_receiveString>
		// Receive the second pass
		UART_receiveString(confirming_password);
    1598:	ce 01       	movw	r24, r28
    159a:	47 96       	adiw	r24, 0x17	; 23
    159c:	0e 94 ff 10 	call	0x21fe	; 0x21fe <UART_receiveString>
		// check the equality of the two passwords
		result =check_password(created_password , confirming_password);
    15a0:	ce 01       	movw	r24, r28
    15a2:	41 96       	adiw	r24, 0x11	; 17
    15a4:	9e 01       	movw	r18, r28
    15a6:	29 5e       	subi	r18, 0xE9	; 233
    15a8:	3f 4f       	sbci	r19, 0xFF	; 255
    15aa:	b9 01       	movw	r22, r18
    15ac:	0e 94 ff 09 	call	0x13fe	; 0x13fe <check_password>
    15b0:	8f 87       	std	Y+15, r24	; 0x0f
		// send the result to the other microcontroller 1
		UART_sendByte(result);
    15b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    15b4:	0e 94 b0 10 	call	0x2160	; 0x2160 <UART_sendByte>
		if (result ==TRUE ){
    15b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    15ba:	81 30       	cpi	r24, 0x01	; 1
    15bc:	41 f4       	brne	.+16     	; 0x15ce <create_password+0x140>
			finish_password=TRUE;  // rasise the flag to indicate that we finsihed
    15be:	81 e0       	ldi	r24, 0x01	; 1
    15c0:	88 8b       	std	Y+16, r24	; 0x10
			save_password(created_password, PASS_ADDRESS);
    15c2:	ce 01       	movw	r24, r28
    15c4:	41 96       	adiw	r24, 0x11	; 17
    15c6:	61 e1       	ldi	r22, 0x11	; 17
    15c8:	73 e0       	ldi	r23, 0x03	; 3
    15ca:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <save_password>
	uint8 created_password [6];
	uint8 confirming_password[6];
	uint8 result;


	while(finish_password == FALSE){
    15ce:	88 89       	ldd	r24, Y+16	; 0x10
    15d0:	88 23       	and	r24, r24
    15d2:	09 f4       	brne	.+2      	; 0x15d6 <create_password+0x148>
    15d4:	68 cf       	rjmp	.-304    	; 0x14a6 <create_password+0x18>
			save_password(created_password, PASS_ADDRESS);
		}

	}

}
    15d6:	6c 96       	adiw	r28, 0x1c	; 28
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	de bf       	out	0x3e, r29	; 62
    15de:	0f be       	out	0x3f, r0	; 63
    15e0:	cd bf       	out	0x3d, r28	; 61
    15e2:	cf 91       	pop	r28
    15e4:	df 91       	pop	r29
    15e6:	08 95       	ret

000015e8 <save_password>:


void save_password(uint8 *pass ,uint16 address){
    15e8:	df 93       	push	r29
    15ea:	cf 93       	push	r28
    15ec:	cd b7       	in	r28, 0x3d	; 61
    15ee:	de b7       	in	r29, 0x3e	; 62
    15f0:	63 97       	sbiw	r28, 0x13	; 19
    15f2:	0f b6       	in	r0, 0x3f	; 63
    15f4:	f8 94       	cli
    15f6:	de bf       	out	0x3e, r29	; 62
    15f8:	0f be       	out	0x3f, r0	; 63
    15fa:	cd bf       	out	0x3d, r28	; 61
    15fc:	99 8b       	std	Y+17, r25	; 0x11
    15fe:	88 8b       	std	Y+16, r24	; 0x10
    1600:	7b 8b       	std	Y+19, r23	; 0x13
    1602:	6a 8b       	std	Y+18, r22	; 0x12
	uint8 i =0;
    1604:	1f 86       	std	Y+15, r1	; 0x0f
    1606:	88 c0       	rjmp	.+272    	; 0x1718 <save_password+0x130>
	while (pass[i]!='\0'){
		EEPROM_writeByte(address, pass[i]);  // write the string byte after byte
    1608:	8f 85       	ldd	r24, Y+15	; 0x0f
    160a:	28 2f       	mov	r18, r24
    160c:	30 e0       	ldi	r19, 0x00	; 0
    160e:	88 89       	ldd	r24, Y+16	; 0x10
    1610:	99 89       	ldd	r25, Y+17	; 0x11
    1612:	fc 01       	movw	r30, r24
    1614:	e2 0f       	add	r30, r18
    1616:	f3 1f       	adc	r31, r19
    1618:	20 81       	ld	r18, Z
    161a:	8a 89       	ldd	r24, Y+18	; 0x12
    161c:	9b 89       	ldd	r25, Y+19	; 0x13
    161e:	62 2f       	mov	r22, r18
    1620:	0e 94 c7 05 	call	0xb8e	; 0xb8e <EEPROM_writeByte>
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	a0 e2       	ldi	r26, 0x20	; 32
    162a:	b1 e4       	ldi	r27, 0x41	; 65
    162c:	8b 87       	std	Y+11, r24	; 0x0b
    162e:	9c 87       	std	Y+12, r25	; 0x0c
    1630:	ad 87       	std	Y+13, r26	; 0x0d
    1632:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1634:	6b 85       	ldd	r22, Y+11	; 0x0b
    1636:	7c 85       	ldd	r23, Y+12	; 0x0c
    1638:	8d 85       	ldd	r24, Y+13	; 0x0d
    163a:	9e 85       	ldd	r25, Y+14	; 0x0e
    163c:	20 e0       	ldi	r18, 0x00	; 0
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	4a ef       	ldi	r20, 0xFA	; 250
    1642:	54 e4       	ldi	r21, 0x44	; 68
    1644:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1648:	dc 01       	movw	r26, r24
    164a:	cb 01       	movw	r24, r22
    164c:	8f 83       	std	Y+7, r24	; 0x07
    164e:	98 87       	std	Y+8, r25	; 0x08
    1650:	a9 87       	std	Y+9, r26	; 0x09
    1652:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1654:	6f 81       	ldd	r22, Y+7	; 0x07
    1656:	78 85       	ldd	r23, Y+8	; 0x08
    1658:	89 85       	ldd	r24, Y+9	; 0x09
    165a:	9a 85       	ldd	r25, Y+10	; 0x0a
    165c:	20 e0       	ldi	r18, 0x00	; 0
    165e:	30 e0       	ldi	r19, 0x00	; 0
    1660:	40 e8       	ldi	r20, 0x80	; 128
    1662:	5f e3       	ldi	r21, 0x3F	; 63
    1664:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1668:	88 23       	and	r24, r24
    166a:	2c f4       	brge	.+10     	; 0x1676 <save_password+0x8e>
		__ticks = 1;
    166c:	81 e0       	ldi	r24, 0x01	; 1
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	9e 83       	std	Y+6, r25	; 0x06
    1672:	8d 83       	std	Y+5, r24	; 0x05
    1674:	3f c0       	rjmp	.+126    	; 0x16f4 <save_password+0x10c>
	else if (__tmp > 65535)
    1676:	6f 81       	ldd	r22, Y+7	; 0x07
    1678:	78 85       	ldd	r23, Y+8	; 0x08
    167a:	89 85       	ldd	r24, Y+9	; 0x09
    167c:	9a 85       	ldd	r25, Y+10	; 0x0a
    167e:	20 e0       	ldi	r18, 0x00	; 0
    1680:	3f ef       	ldi	r19, 0xFF	; 255
    1682:	4f e7       	ldi	r20, 0x7F	; 127
    1684:	57 e4       	ldi	r21, 0x47	; 71
    1686:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    168a:	18 16       	cp	r1, r24
    168c:	4c f5       	brge	.+82     	; 0x16e0 <save_password+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    168e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1690:	7c 85       	ldd	r23, Y+12	; 0x0c
    1692:	8d 85       	ldd	r24, Y+13	; 0x0d
    1694:	9e 85       	ldd	r25, Y+14	; 0x0e
    1696:	20 e0       	ldi	r18, 0x00	; 0
    1698:	30 e0       	ldi	r19, 0x00	; 0
    169a:	40 e2       	ldi	r20, 0x20	; 32
    169c:	51 e4       	ldi	r21, 0x41	; 65
    169e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16a2:	dc 01       	movw	r26, r24
    16a4:	cb 01       	movw	r24, r22
    16a6:	bc 01       	movw	r22, r24
    16a8:	cd 01       	movw	r24, r26
    16aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16ae:	dc 01       	movw	r26, r24
    16b0:	cb 01       	movw	r24, r22
    16b2:	9e 83       	std	Y+6, r25	; 0x06
    16b4:	8d 83       	std	Y+5, r24	; 0x05
    16b6:	0f c0       	rjmp	.+30     	; 0x16d6 <save_password+0xee>
    16b8:	88 ec       	ldi	r24, 0xC8	; 200
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	9c 83       	std	Y+4, r25	; 0x04
    16be:	8b 83       	std	Y+3, r24	; 0x03
    16c0:	8b 81       	ldd	r24, Y+3	; 0x03
    16c2:	9c 81       	ldd	r25, Y+4	; 0x04
    16c4:	01 97       	sbiw	r24, 0x01	; 1
    16c6:	f1 f7       	brne	.-4      	; 0x16c4 <save_password+0xdc>
    16c8:	9c 83       	std	Y+4, r25	; 0x04
    16ca:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16cc:	8d 81       	ldd	r24, Y+5	; 0x05
    16ce:	9e 81       	ldd	r25, Y+6	; 0x06
    16d0:	01 97       	sbiw	r24, 0x01	; 1
    16d2:	9e 83       	std	Y+6, r25	; 0x06
    16d4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16d6:	8d 81       	ldd	r24, Y+5	; 0x05
    16d8:	9e 81       	ldd	r25, Y+6	; 0x06
    16da:	00 97       	sbiw	r24, 0x00	; 0
    16dc:	69 f7       	brne	.-38     	; 0x16b8 <save_password+0xd0>
    16de:	14 c0       	rjmp	.+40     	; 0x1708 <save_password+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16e0:	6f 81       	ldd	r22, Y+7	; 0x07
    16e2:	78 85       	ldd	r23, Y+8	; 0x08
    16e4:	89 85       	ldd	r24, Y+9	; 0x09
    16e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    16e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16ec:	dc 01       	movw	r26, r24
    16ee:	cb 01       	movw	r24, r22
    16f0:	9e 83       	std	Y+6, r25	; 0x06
    16f2:	8d 83       	std	Y+5, r24	; 0x05
    16f4:	8d 81       	ldd	r24, Y+5	; 0x05
    16f6:	9e 81       	ldd	r25, Y+6	; 0x06
    16f8:	9a 83       	std	Y+2, r25	; 0x02
    16fa:	89 83       	std	Y+1, r24	; 0x01
    16fc:	89 81       	ldd	r24, Y+1	; 0x01
    16fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1700:	01 97       	sbiw	r24, 0x01	; 1
    1702:	f1 f7       	brne	.-4      	; 0x1700 <save_password+0x118>
    1704:	9a 83       	std	Y+2, r25	; 0x02
    1706:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(10);
		i++;
    1708:	8f 85       	ldd	r24, Y+15	; 0x0f
    170a:	8f 5f       	subi	r24, 0xFF	; 255
    170c:	8f 87       	std	Y+15, r24	; 0x0f
		address++;
    170e:	8a 89       	ldd	r24, Y+18	; 0x12
    1710:	9b 89       	ldd	r25, Y+19	; 0x13
    1712:	01 96       	adiw	r24, 0x01	; 1
    1714:	9b 8b       	std	Y+19, r25	; 0x13
    1716:	8a 8b       	std	Y+18, r24	; 0x12
}


void save_password(uint8 *pass ,uint16 address){
	uint8 i =0;
	while (pass[i]!='\0'){
    1718:	8f 85       	ldd	r24, Y+15	; 0x0f
    171a:	28 2f       	mov	r18, r24
    171c:	30 e0       	ldi	r19, 0x00	; 0
    171e:	88 89       	ldd	r24, Y+16	; 0x10
    1720:	99 89       	ldd	r25, Y+17	; 0x11
    1722:	fc 01       	movw	r30, r24
    1724:	e2 0f       	add	r30, r18
    1726:	f3 1f       	adc	r31, r19
    1728:	80 81       	ld	r24, Z
    172a:	88 23       	and	r24, r24
    172c:	09 f0       	breq	.+2      	; 0x1730 <save_password+0x148>
    172e:	6c cf       	rjmp	.-296    	; 0x1608 <save_password+0x20>
		_delay_ms(10);
		i++;
		address++;
	}

}
    1730:	63 96       	adiw	r28, 0x13	; 19
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	f8 94       	cli
    1736:	de bf       	out	0x3e, r29	; 62
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	cd bf       	out	0x3d, r28	; 61
    173c:	cf 91       	pop	r28
    173e:	df 91       	pop	r29
    1740:	08 95       	ret

00001742 <check_entered_password>:

boolean check_entered_password(void){
    1742:	df 93       	push	r29
    1744:	cf 93       	push	r28
    1746:	cd b7       	in	r28, 0x3d	; 61
    1748:	de b7       	in	r29, 0x3e	; 62
    174a:	2c 97       	sbiw	r28, 0x0c	; 12
    174c:	0f b6       	in	r0, 0x3f	; 63
    174e:	f8 94       	cli
    1750:	de bf       	out	0x3e, r29	; 62
    1752:	0f be       	out	0x3f, r0	; 63
    1754:	cd bf       	out	0x3d, r28	; 61
	/*create two strings to save the entered pass and the saved one */
	uint8  entered_pass [6];
	uint8  saved_pass[6] ;
	/* receive the entered pass from the first  microcontroller*/
	UART_receiveString(entered_pass);
    1756:	ce 01       	movw	r24, r28
    1758:	01 96       	adiw	r24, 0x01	; 1
    175a:	0e 94 ff 10 	call	0x21fe	; 0x21fe <UART_receiveString>
	/* get the password saved from the EEPROM */
	get_password(saved_pass,PASS_ADDRESS);
    175e:	ce 01       	movw	r24, r28
    1760:	07 96       	adiw	r24, 0x07	; 7
    1762:	61 e1       	ldi	r22, 0x11	; 17
    1764:	73 e0       	ldi	r23, 0x03	; 3
    1766:	0e 94 c6 0b 	call	0x178c	; 0x178c <get_password>
	/* checks the equality of the passwords and return the result*/
	return (check_password(entered_pass , saved_pass));
    176a:	9e 01       	movw	r18, r28
    176c:	29 5f       	subi	r18, 0xF9	; 249
    176e:	3f 4f       	sbci	r19, 0xFF	; 255
    1770:	ce 01       	movw	r24, r28
    1772:	01 96       	adiw	r24, 0x01	; 1
    1774:	b9 01       	movw	r22, r18
    1776:	0e 94 ff 09 	call	0x13fe	; 0x13fe <check_password>


}
    177a:	2c 96       	adiw	r28, 0x0c	; 12
    177c:	0f b6       	in	r0, 0x3f	; 63
    177e:	f8 94       	cli
    1780:	de bf       	out	0x3e, r29	; 62
    1782:	0f be       	out	0x3f, r0	; 63
    1784:	cd bf       	out	0x3d, r28	; 61
    1786:	cf 91       	pop	r28
    1788:	df 91       	pop	r29
    178a:	08 95       	ret

0000178c <get_password>:
void get_password(uint8 *pass , uint16 address){
    178c:	df 93       	push	r29
    178e:	cf 93       	push	r28
    1790:	cd b7       	in	r28, 0x3d	; 61
    1792:	de b7       	in	r29, 0x3e	; 62
    1794:	63 97       	sbiw	r28, 0x13	; 19
    1796:	0f b6       	in	r0, 0x3f	; 63
    1798:	f8 94       	cli
    179a:	de bf       	out	0x3e, r29	; 62
    179c:	0f be       	out	0x3f, r0	; 63
    179e:	cd bf       	out	0x3d, r28	; 61
    17a0:	99 8b       	std	Y+17, r25	; 0x11
    17a2:	88 8b       	std	Y+16, r24	; 0x10
    17a4:	7b 8b       	std	Y+19, r23	; 0x13
    17a6:	6a 8b       	std	Y+18, r22	; 0x12
	uint8 i =0;
    17a8:	1f 86       	std	Y+15, r1	; 0x0f
    17aa:	86 c0       	rjmp	.+268    	; 0x18b8 <get_password+0x12c>
	/* loop on the password bytes */
	while (i<5){
		EEPROM_readByte(address, pass+i);  // extract the password saved
    17ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    17ae:	28 2f       	mov	r18, r24
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	88 89       	ldd	r24, Y+16	; 0x10
    17b4:	99 89       	ldd	r25, Y+17	; 0x11
    17b6:	28 0f       	add	r18, r24
    17b8:	39 1f       	adc	r19, r25
    17ba:	8a 89       	ldd	r24, Y+18	; 0x12
    17bc:	9b 89       	ldd	r25, Y+19	; 0x13
    17be:	b9 01       	movw	r22, r18
    17c0:	0e 94 08 06 	call	0xc10	; 0xc10 <EEPROM_readByte>
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	a0 e2       	ldi	r26, 0x20	; 32
    17ca:	b1 e4       	ldi	r27, 0x41	; 65
    17cc:	8b 87       	std	Y+11, r24	; 0x0b
    17ce:	9c 87       	std	Y+12, r25	; 0x0c
    17d0:	ad 87       	std	Y+13, r26	; 0x0d
    17d2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    17d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    17d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    17da:	9e 85       	ldd	r25, Y+14	; 0x0e
    17dc:	20 e0       	ldi	r18, 0x00	; 0
    17de:	30 e0       	ldi	r19, 0x00	; 0
    17e0:	4a ef       	ldi	r20, 0xFA	; 250
    17e2:	54 e4       	ldi	r21, 0x44	; 68
    17e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17e8:	dc 01       	movw	r26, r24
    17ea:	cb 01       	movw	r24, r22
    17ec:	8f 83       	std	Y+7, r24	; 0x07
    17ee:	98 87       	std	Y+8, r25	; 0x08
    17f0:	a9 87       	std	Y+9, r26	; 0x09
    17f2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    17f4:	6f 81       	ldd	r22, Y+7	; 0x07
    17f6:	78 85       	ldd	r23, Y+8	; 0x08
    17f8:	89 85       	ldd	r24, Y+9	; 0x09
    17fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    17fc:	20 e0       	ldi	r18, 0x00	; 0
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	40 e8       	ldi	r20, 0x80	; 128
    1802:	5f e3       	ldi	r21, 0x3F	; 63
    1804:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1808:	88 23       	and	r24, r24
    180a:	2c f4       	brge	.+10     	; 0x1816 <get_password+0x8a>
		__ticks = 1;
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	9e 83       	std	Y+6, r25	; 0x06
    1812:	8d 83       	std	Y+5, r24	; 0x05
    1814:	3f c0       	rjmp	.+126    	; 0x1894 <get_password+0x108>
	else if (__tmp > 65535)
    1816:	6f 81       	ldd	r22, Y+7	; 0x07
    1818:	78 85       	ldd	r23, Y+8	; 0x08
    181a:	89 85       	ldd	r24, Y+9	; 0x09
    181c:	9a 85       	ldd	r25, Y+10	; 0x0a
    181e:	20 e0       	ldi	r18, 0x00	; 0
    1820:	3f ef       	ldi	r19, 0xFF	; 255
    1822:	4f e7       	ldi	r20, 0x7F	; 127
    1824:	57 e4       	ldi	r21, 0x47	; 71
    1826:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    182a:	18 16       	cp	r1, r24
    182c:	4c f5       	brge	.+82     	; 0x1880 <get_password+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    182e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1830:	7c 85       	ldd	r23, Y+12	; 0x0c
    1832:	8d 85       	ldd	r24, Y+13	; 0x0d
    1834:	9e 85       	ldd	r25, Y+14	; 0x0e
    1836:	20 e0       	ldi	r18, 0x00	; 0
    1838:	30 e0       	ldi	r19, 0x00	; 0
    183a:	40 e2       	ldi	r20, 0x20	; 32
    183c:	51 e4       	ldi	r21, 0x41	; 65
    183e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1842:	dc 01       	movw	r26, r24
    1844:	cb 01       	movw	r24, r22
    1846:	bc 01       	movw	r22, r24
    1848:	cd 01       	movw	r24, r26
    184a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    184e:	dc 01       	movw	r26, r24
    1850:	cb 01       	movw	r24, r22
    1852:	9e 83       	std	Y+6, r25	; 0x06
    1854:	8d 83       	std	Y+5, r24	; 0x05
    1856:	0f c0       	rjmp	.+30     	; 0x1876 <get_password+0xea>
    1858:	88 ec       	ldi	r24, 0xC8	; 200
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	9c 83       	std	Y+4, r25	; 0x04
    185e:	8b 83       	std	Y+3, r24	; 0x03
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	f1 f7       	brne	.-4      	; 0x1864 <get_password+0xd8>
    1868:	9c 83       	std	Y+4, r25	; 0x04
    186a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    186c:	8d 81       	ldd	r24, Y+5	; 0x05
    186e:	9e 81       	ldd	r25, Y+6	; 0x06
    1870:	01 97       	sbiw	r24, 0x01	; 1
    1872:	9e 83       	std	Y+6, r25	; 0x06
    1874:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1876:	8d 81       	ldd	r24, Y+5	; 0x05
    1878:	9e 81       	ldd	r25, Y+6	; 0x06
    187a:	00 97       	sbiw	r24, 0x00	; 0
    187c:	69 f7       	brne	.-38     	; 0x1858 <get_password+0xcc>
    187e:	14 c0       	rjmp	.+40     	; 0x18a8 <get_password+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1880:	6f 81       	ldd	r22, Y+7	; 0x07
    1882:	78 85       	ldd	r23, Y+8	; 0x08
    1884:	89 85       	ldd	r24, Y+9	; 0x09
    1886:	9a 85       	ldd	r25, Y+10	; 0x0a
    1888:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    188c:	dc 01       	movw	r26, r24
    188e:	cb 01       	movw	r24, r22
    1890:	9e 83       	std	Y+6, r25	; 0x06
    1892:	8d 83       	std	Y+5, r24	; 0x05
    1894:	8d 81       	ldd	r24, Y+5	; 0x05
    1896:	9e 81       	ldd	r25, Y+6	; 0x06
    1898:	9a 83       	std	Y+2, r25	; 0x02
    189a:	89 83       	std	Y+1, r24	; 0x01
    189c:	89 81       	ldd	r24, Y+1	; 0x01
    189e:	9a 81       	ldd	r25, Y+2	; 0x02
    18a0:	01 97       	sbiw	r24, 0x01	; 1
    18a2:	f1 f7       	brne	.-4      	; 0x18a0 <get_password+0x114>
    18a4:	9a 83       	std	Y+2, r25	; 0x02
    18a6:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(10);
		i++;
    18a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    18aa:	8f 5f       	subi	r24, 0xFF	; 255
    18ac:	8f 87       	std	Y+15, r24	; 0x0f
		address++;
    18ae:	8a 89       	ldd	r24, Y+18	; 0x12
    18b0:	9b 89       	ldd	r25, Y+19	; 0x13
    18b2:	01 96       	adiw	r24, 0x01	; 1
    18b4:	9b 8b       	std	Y+19, r25	; 0x13
    18b6:	8a 8b       	std	Y+18, r24	; 0x12

}
void get_password(uint8 *pass , uint16 address){
	uint8 i =0;
	/* loop on the password bytes */
	while (i<5){
    18b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    18ba:	85 30       	cpi	r24, 0x05	; 5
    18bc:	08 f4       	brcc	.+2      	; 0x18c0 <get_password+0x134>
    18be:	76 cf       	rjmp	.-276    	; 0x17ac <get_password+0x20>
		EEPROM_readByte(address, pass+i);  // extract the password saved
		_delay_ms(10);
		i++;
		address++;
	}
	pass[5]='\0';
    18c0:	88 89       	ldd	r24, Y+16	; 0x10
    18c2:	99 89       	ldd	r25, Y+17	; 0x11
    18c4:	fc 01       	movw	r30, r24
    18c6:	35 96       	adiw	r30, 0x05	; 5
    18c8:	10 82       	st	Z, r1

}
    18ca:	63 96       	adiw	r28, 0x13	; 19
    18cc:	0f b6       	in	r0, 0x3f	; 63
    18ce:	f8 94       	cli
    18d0:	de bf       	out	0x3e, r29	; 62
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	cd bf       	out	0x3d, r28	; 61
    18d6:	cf 91       	pop	r28
    18d8:	df 91       	pop	r29
    18da:	08 95       	ret

000018dc <do_action>:
boolean do_action(void){
    18dc:	df 93       	push	r29
    18de:	cf 93       	push	r28
    18e0:	00 d0       	rcall	.+0      	; 0x18e2 <do_action+0x6>
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
	// check on the password received from other controller
	boolean result =check_entered_password();
    18e6:	0e 94 a1 0b 	call	0x1742	; 0x1742 <check_entered_password>
    18ea:	8a 83       	std	Y+2, r24	; 0x02
	// send the result to other controller to
	UART_sendByte(result);
    18ec:	8a 81       	ldd	r24, Y+2	; 0x02
    18ee:	0e 94 b0 10 	call	0x2160	; 0x2160 <UART_sendByte>
	if (result ==TRUE){
    18f2:	8a 81       	ldd	r24, Y+2	; 0x02
    18f4:	81 30       	cpi	r24, 0x01	; 1
    18f6:	79 f4       	brne	.+30     	; 0x1916 <do_action+0x3a>
		// if the result is True receive the action to be done from the other
		//controller
		uint8 option= UART_recieveByte();
    18f8:	0e 94 c7 10 	call	0x218e	; 0x218e <UART_recieveByte>
    18fc:	89 83       	std	Y+1, r24	; 0x01
		if (option=='+'){
    18fe:	89 81       	ldd	r24, Y+1	; 0x01
    1900:	8b 32       	cpi	r24, 0x2B	; 43
    1902:	39 f4       	brne	.+14     	; 0x1912 <do_action+0x36>
			unlock_door();
    1904:	0e 94 91 0c 	call	0x1922	; 0x1922 <unlock_door>
			hold_door();
    1908:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <hold_door>
			lock_door();
    190c:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <lock_door>
    1910:	02 c0       	rjmp	.+4      	; 0x1916 <do_action+0x3a>



		}
		else{
			create_password();
    1912:	0e 94 47 0a 	call	0x148e	; 0x148e <create_password>
	else{

	}


	return result;
    1916:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1918:	0f 90       	pop	r0
    191a:	0f 90       	pop	r0
    191c:	cf 91       	pop	r28
    191e:	df 91       	pop	r29
    1920:	08 95       	ret

00001922 <unlock_door>:

void unlock_door(void){
    1922:	df 93       	push	r29
    1924:	cf 93       	push	r28
    1926:	cd b7       	in	r28, 0x3d	; 61
    1928:	de b7       	in	r29, 0x3e	; 62
    192a:	2b 97       	sbiw	r28, 0x0b	; 11
    192c:	0f b6       	in	r0, 0x3f	; 63
    192e:	f8 94       	cli
    1930:	de bf       	out	0x3e, r29	; 62
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	cd bf       	out	0x3d, r28	; 61
	DcMotor_Rotate(CW,100);
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	64 e6       	ldi	r22, 0x64	; 100
    193a:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <DcMotor_Rotate>
	Timer1_setCallBack(lock_unlock);
    193e:	81 e2       	ldi	r24, 0x21	; 33
    1940:	9d e0       	ldi	r25, 0x0D	; 13
    1942:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <Timer1_setCallBack>
	 * initial_value = 65535 - 62500 =3035
	 * compare_value =0
	 * prescaler = 1024
	 * mode :normal_mode
	 */
	Timer1_ConfigType timer_configuration = {3035,0,F_CPU_1024,NORMAL};
    1946:	ce 01       	movw	r24, r28
    1948:	01 96       	adiw	r24, 0x01	; 1
    194a:	98 87       	std	Y+8, r25	; 0x08
    194c:	8f 83       	std	Y+7, r24	; 0x07
    194e:	ef e6       	ldi	r30, 0x6F	; 111
    1950:	f0 e0       	ldi	r31, 0x00	; 0
    1952:	fa 87       	std	Y+10, r31	; 0x0a
    1954:	e9 87       	std	Y+9, r30	; 0x09
    1956:	f6 e0       	ldi	r31, 0x06	; 6
    1958:	fb 87       	std	Y+11, r31	; 0x0b
    195a:	e9 85       	ldd	r30, Y+9	; 0x09
    195c:	fa 85       	ldd	r31, Y+10	; 0x0a
    195e:	00 80       	ld	r0, Z
    1960:	89 85       	ldd	r24, Y+9	; 0x09
    1962:	9a 85       	ldd	r25, Y+10	; 0x0a
    1964:	01 96       	adiw	r24, 0x01	; 1
    1966:	9a 87       	std	Y+10, r25	; 0x0a
    1968:	89 87       	std	Y+9, r24	; 0x09
    196a:	ef 81       	ldd	r30, Y+7	; 0x07
    196c:	f8 85       	ldd	r31, Y+8	; 0x08
    196e:	00 82       	st	Z, r0
    1970:	8f 81       	ldd	r24, Y+7	; 0x07
    1972:	98 85       	ldd	r25, Y+8	; 0x08
    1974:	01 96       	adiw	r24, 0x01	; 1
    1976:	98 87       	std	Y+8, r25	; 0x08
    1978:	8f 83       	std	Y+7, r24	; 0x07
    197a:	9b 85       	ldd	r25, Y+11	; 0x0b
    197c:	91 50       	subi	r25, 0x01	; 1
    197e:	9b 87       	std	Y+11, r25	; 0x0b
    1980:	eb 85       	ldd	r30, Y+11	; 0x0b
    1982:	ee 23       	and	r30, r30
    1984:	51 f7       	brne	.-44     	; 0x195a <unlock_door+0x38>
	Timer1_init(&timer_configuration);
    1986:	ce 01       	movw	r24, r28
    1988:	01 96       	adiw	r24, 0x01	; 1
    198a:	0e 94 77 0e 	call	0x1cee	; 0x1cee <Timer1_init>
	// wait for the interrupt to change the value of wait to false
	wait = TRUE ;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	80 93 88 00 	sts	0x0088, r24
	while(wait);
    1994:	80 91 88 00 	lds	r24, 0x0088
    1998:	88 23       	and	r24, r24
    199a:	e1 f7       	brne	.-8      	; 0x1994 <unlock_door+0x72>

}
    199c:	2b 96       	adiw	r28, 0x0b	; 11
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	de bf       	out	0x3e, r29	; 62
    19a4:	0f be       	out	0x3f, r0	; 63
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	cf 91       	pop	r28
    19aa:	df 91       	pop	r29
    19ac:	08 95       	ret

000019ae <lock_door>:


void lock_door(void){
    19ae:	df 93       	push	r29
    19b0:	cf 93       	push	r28
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62
    19b6:	2b 97       	sbiw	r28, 0x0b	; 11
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	de bf       	out	0x3e, r29	; 62
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	cd bf       	out	0x3d, r28	; 61
	DcMotor_Rotate(A_CW,100);
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	64 e6       	ldi	r22, 0x64	; 100
    19c6:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <DcMotor_Rotate>
	Timer1_setCallBack(lock_unlock);
    19ca:	81 e2       	ldi	r24, 0x21	; 33
    19cc:	9d e0       	ldi	r25, 0x0D	; 13
    19ce:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <Timer1_setCallBack>
	 * initial_value = 65535 - 62500 =3035
	 * compare_value =0
	 * prescaler = 1024
	 * mode :normal_mode
	 */
	Timer1_ConfigType timer_configuration = {3035,0,F_CPU_1024,NORMAL};
    19d2:	ce 01       	movw	r24, r28
    19d4:	01 96       	adiw	r24, 0x01	; 1
    19d6:	98 87       	std	Y+8, r25	; 0x08
    19d8:	8f 83       	std	Y+7, r24	; 0x07
    19da:	e5 e7       	ldi	r30, 0x75	; 117
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	fa 87       	std	Y+10, r31	; 0x0a
    19e0:	e9 87       	std	Y+9, r30	; 0x09
    19e2:	f6 e0       	ldi	r31, 0x06	; 6
    19e4:	fb 87       	std	Y+11, r31	; 0x0b
    19e6:	e9 85       	ldd	r30, Y+9	; 0x09
    19e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    19ea:	00 80       	ld	r0, Z
    19ec:	89 85       	ldd	r24, Y+9	; 0x09
    19ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    19f0:	01 96       	adiw	r24, 0x01	; 1
    19f2:	9a 87       	std	Y+10, r25	; 0x0a
    19f4:	89 87       	std	Y+9, r24	; 0x09
    19f6:	ef 81       	ldd	r30, Y+7	; 0x07
    19f8:	f8 85       	ldd	r31, Y+8	; 0x08
    19fa:	00 82       	st	Z, r0
    19fc:	8f 81       	ldd	r24, Y+7	; 0x07
    19fe:	98 85       	ldd	r25, Y+8	; 0x08
    1a00:	01 96       	adiw	r24, 0x01	; 1
    1a02:	98 87       	std	Y+8, r25	; 0x08
    1a04:	8f 83       	std	Y+7, r24	; 0x07
    1a06:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a08:	91 50       	subi	r25, 0x01	; 1
    1a0a:	9b 87       	std	Y+11, r25	; 0x0b
    1a0c:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a0e:	ee 23       	and	r30, r30
    1a10:	51 f7       	brne	.-44     	; 0x19e6 <lock_door+0x38>
	Timer1_init(&timer_configuration);
    1a12:	ce 01       	movw	r24, r28
    1a14:	01 96       	adiw	r24, 0x01	; 1
    1a16:	0e 94 77 0e 	call	0x1cee	; 0x1cee <Timer1_init>
	// wait for the interrupt to change the value of wait to false
	wait = TRUE ;
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
    1a1c:	80 93 88 00 	sts	0x0088, r24
	while(wait);
    1a20:	80 91 88 00 	lds	r24, 0x0088
    1a24:	88 23       	and	r24, r24
    1a26:	e1 f7       	brne	.-8      	; 0x1a20 <lock_door+0x72>
	DcMotor_Rotate(STOP,0);
    1a28:	82 e0       	ldi	r24, 0x02	; 2
    1a2a:	60 e0       	ldi	r22, 0x00	; 0
    1a2c:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <DcMotor_Rotate>
}
    1a30:	2b 96       	adiw	r28, 0x0b	; 11
    1a32:	0f b6       	in	r0, 0x3f	; 63
    1a34:	f8 94       	cli
    1a36:	de bf       	out	0x3e, r29	; 62
    1a38:	0f be       	out	0x3f, r0	; 63
    1a3a:	cd bf       	out	0x3d, r28	; 61
    1a3c:	cf 91       	pop	r28
    1a3e:	df 91       	pop	r29
    1a40:	08 95       	ret

00001a42 <lock_unlock>:


void lock_unlock(void){
    1a42:	df 93       	push	r29
    1a44:	cf 93       	push	r28
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
	super_tick++;
    1a4a:	80 91 8a 00 	lds	r24, 0x008A
    1a4e:	8f 5f       	subi	r24, 0xFF	; 255
    1a50:	80 93 8a 00 	sts	0x008A, r24
	if  (super_tick == 2) {
    1a54:	80 91 8a 00 	lds	r24, 0x008A
    1a58:	82 30       	cpi	r24, 0x02	; 2
    1a5a:	39 f4       	brne	.+14     	; 0x1a6a <lock_unlock+0x28>
		wait = FALSE ;
    1a5c:	10 92 88 00 	sts	0x0088, r1
		super_tick = 0 ;
    1a60:	10 92 8a 00 	sts	0x008A, r1
		Timer1_deInit() ;
    1a64:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <Timer1_deInit>
    1a68:	06 c0       	rjmp	.+12     	; 0x1a76 <lock_unlock+0x34>
		 * c_freq = 8000000/1024 = 7812
		 * tick_time = 1.28 * 10**-4 seconds
		 * so to get 7 seconds we need 7/tick_time = 54688 ticks
		 * initial_value = 65535-54688 = 10874
		 */
		TCNT1 =10874;
    1a6a:	ec e4       	ldi	r30, 0x4C	; 76
    1a6c:	f0 e0       	ldi	r31, 0x00	; 0
    1a6e:	8a e7       	ldi	r24, 0x7A	; 122
    1a70:	9a e2       	ldi	r25, 0x2A	; 42
    1a72:	91 83       	std	Z+1, r25	; 0x01
    1a74:	80 83       	st	Z, r24

	}

}
    1a76:	cf 91       	pop	r28
    1a78:	df 91       	pop	r29
    1a7a:	08 95       	ret

00001a7c <hold_ISR>:
void hold_ISR(void){
    1a7c:	df 93       	push	r29
    1a7e:	cf 93       	push	r28
    1a80:	cd b7       	in	r28, 0x3d	; 61
    1a82:	de b7       	in	r29, 0x3e	; 62
	wait = FALSE ;
    1a84:	10 92 88 00 	sts	0x0088, r1
	super_tick = 0 ;
    1a88:	10 92 8a 00 	sts	0x008A, r1
	Timer1_deInit() ;
    1a8c:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <Timer1_deInit>
}
    1a90:	cf 91       	pop	r28
    1a92:	df 91       	pop	r29
    1a94:	08 95       	ret

00001a96 <hold_door>:
void hold_door(void){
    1a96:	df 93       	push	r29
    1a98:	cf 93       	push	r28
    1a9a:	cd b7       	in	r28, 0x3d	; 61
    1a9c:	de b7       	in	r29, 0x3e	; 62
    1a9e:	2b 97       	sbiw	r28, 0x0b	; 11
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	de bf       	out	0x3e, r29	; 62
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	cd bf       	out	0x3d, r28	; 61
	DcMotor_Rotate(STOP,0);
    1aaa:	82 e0       	ldi	r24, 0x02	; 2
    1aac:	60 e0       	ldi	r22, 0x00	; 0
    1aae:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <DcMotor_Rotate>
	Timer1_setCallBack(hold_ISR);
    1ab2:	8e e3       	ldi	r24, 0x3E	; 62
    1ab4:	9d e0       	ldi	r25, 0x0D	; 13
    1ab6:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <Timer1_setCallBack>
	 * initial_value = 65535 - 62500 =42097
	 * compare_value =0
	 * prescaler = 1024
	 * mode :normal_mode
	 */
	Timer1_ConfigType timer_configuration = {42097,0,F_CPU_1024,NORMAL};
    1aba:	ce 01       	movw	r24, r28
    1abc:	01 96       	adiw	r24, 0x01	; 1
    1abe:	98 87       	std	Y+8, r25	; 0x08
    1ac0:	8f 83       	std	Y+7, r24	; 0x07
    1ac2:	eb e7       	ldi	r30, 0x7B	; 123
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	fa 87       	std	Y+10, r31	; 0x0a
    1ac8:	e9 87       	std	Y+9, r30	; 0x09
    1aca:	f6 e0       	ldi	r31, 0x06	; 6
    1acc:	fb 87       	std	Y+11, r31	; 0x0b
    1ace:	e9 85       	ldd	r30, Y+9	; 0x09
    1ad0:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ad2:	00 80       	ld	r0, Z
    1ad4:	89 85       	ldd	r24, Y+9	; 0x09
    1ad6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ad8:	01 96       	adiw	r24, 0x01	; 1
    1ada:	9a 87       	std	Y+10, r25	; 0x0a
    1adc:	89 87       	std	Y+9, r24	; 0x09
    1ade:	ef 81       	ldd	r30, Y+7	; 0x07
    1ae0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ae2:	00 82       	st	Z, r0
    1ae4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ae6:	98 85       	ldd	r25, Y+8	; 0x08
    1ae8:	01 96       	adiw	r24, 0x01	; 1
    1aea:	98 87       	std	Y+8, r25	; 0x08
    1aec:	8f 83       	std	Y+7, r24	; 0x07
    1aee:	9b 85       	ldd	r25, Y+11	; 0x0b
    1af0:	91 50       	subi	r25, 0x01	; 1
    1af2:	9b 87       	std	Y+11, r25	; 0x0b
    1af4:	eb 85       	ldd	r30, Y+11	; 0x0b
    1af6:	ee 23       	and	r30, r30
    1af8:	51 f7       	brne	.-44     	; 0x1ace <hold_door+0x38>
	Timer1_init(&timer_configuration);
    1afa:	ce 01       	movw	r24, r28
    1afc:	01 96       	adiw	r24, 0x01	; 1
    1afe:	0e 94 77 0e 	call	0x1cee	; 0x1cee <Timer1_init>
	// wait for the interrupt to change the value of wait to false
	wait = TRUE ;
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	80 93 88 00 	sts	0x0088, r24
	while(wait);
    1b08:	80 91 88 00 	lds	r24, 0x0088
    1b0c:	88 23       	and	r24, r24
    1b0e:	e1 f7       	brne	.-8      	; 0x1b08 <hold_door+0x72>

}
    1b10:	2b 96       	adiw	r28, 0x0b	; 11
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	de bf       	out	0x3e, r29	; 62
    1b18:	0f be       	out	0x3f, r0	; 63
    1b1a:	cd bf       	out	0x3d, r28	; 61
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <error_ISR>:
void error_ISR(void){
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	cd b7       	in	r28, 0x3d	; 61
    1b28:	de b7       	in	r29, 0x3e	; 62
	super_tick++;
    1b2a:	80 91 8a 00 	lds	r24, 0x008A
    1b2e:	8f 5f       	subi	r24, 0xFF	; 255
    1b30:	80 93 8a 00 	sts	0x008A, r24
	if  (super_tick == 10) {
    1b34:	80 91 8a 00 	lds	r24, 0x008A
    1b38:	8a 30       	cpi	r24, 0x0A	; 10
    1b3a:	39 f4       	brne	.+14     	; 0x1b4a <error_ISR+0x28>
		error = FALSE ;
    1b3c:	10 92 89 00 	sts	0x0089, r1
		super_tick = 0 ;
    1b40:	10 92 8a 00 	sts	0x008A, r1
		Timer1_deInit() ;
    1b44:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <Timer1_deInit>
    1b48:	06 c0       	rjmp	.+12     	; 0x1b56 <error_ISR+0x34>

	}
	else{
		TCNT1 =18660;
    1b4a:	ec e4       	ldi	r30, 0x4C	; 76
    1b4c:	f0 e0       	ldi	r31, 0x00	; 0
    1b4e:	84 ee       	ldi	r24, 0xE4	; 228
    1b50:	98 e4       	ldi	r25, 0x48	; 72
    1b52:	91 83       	std	Z+1, r25	; 0x01
    1b54:	80 83       	st	Z, r24
	}
}
    1b56:	cf 91       	pop	r28
    1b58:	df 91       	pop	r29
    1b5a:	08 95       	ret

00001b5c <handle_error>:
void handle_error(void){
    1b5c:	df 93       	push	r29
    1b5e:	cf 93       	push	r28
    1b60:	cd b7       	in	r28, 0x3d	; 61
    1b62:	de b7       	in	r29, 0x3e	; 62
    1b64:	2b 97       	sbiw	r28, 0x0b	; 11
    1b66:	0f b6       	in	r0, 0x3f	; 63
    1b68:	f8 94       	cli
    1b6a:	de bf       	out	0x3e, r29	; 62
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	cd bf       	out	0x3d, r28	; 61
	Buzzer_on();   // display the wrong_pass
    1b70:	0e 94 af 05 	call	0xb5e	; 0xb5e <Buzzer_on>
	error = TRUE ;
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	80 93 89 00 	sts	0x0089, r24
	Timer1_setCallBack(error_ISR);
    1b7a:	81 e9       	ldi	r24, 0x91	; 145
    1b7c:	9d e0       	ldi	r25, 0x0D	; 13
    1b7e:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <Timer1_setCallBack>
	 * compare_value = 0
	 * pre scaler = 1024
	 * mode :normal_mode
	 * time after each interrupt = 46875 *(1/(8000000/1024))
	 */
	Timer1_ConfigType timer_configurations = {18660,0,F_CPU_1024,NORMAL};
    1b82:	ce 01       	movw	r24, r28
    1b84:	01 96       	adiw	r24, 0x01	; 1
    1b86:	98 87       	std	Y+8, r25	; 0x08
    1b88:	8f 83       	std	Y+7, r24	; 0x07
    1b8a:	e1 e8       	ldi	r30, 0x81	; 129
    1b8c:	f0 e0       	ldi	r31, 0x00	; 0
    1b8e:	fa 87       	std	Y+10, r31	; 0x0a
    1b90:	e9 87       	std	Y+9, r30	; 0x09
    1b92:	f6 e0       	ldi	r31, 0x06	; 6
    1b94:	fb 87       	std	Y+11, r31	; 0x0b
    1b96:	e9 85       	ldd	r30, Y+9	; 0x09
    1b98:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b9a:	00 80       	ld	r0, Z
    1b9c:	89 85       	ldd	r24, Y+9	; 0x09
    1b9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ba0:	01 96       	adiw	r24, 0x01	; 1
    1ba2:	9a 87       	std	Y+10, r25	; 0x0a
    1ba4:	89 87       	std	Y+9, r24	; 0x09
    1ba6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ba8:	f8 85       	ldd	r31, Y+8	; 0x08
    1baa:	00 82       	st	Z, r0
    1bac:	8f 81       	ldd	r24, Y+7	; 0x07
    1bae:	98 85       	ldd	r25, Y+8	; 0x08
    1bb0:	01 96       	adiw	r24, 0x01	; 1
    1bb2:	98 87       	std	Y+8, r25	; 0x08
    1bb4:	8f 83       	std	Y+7, r24	; 0x07
    1bb6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bb8:	91 50       	subi	r25, 0x01	; 1
    1bba:	9b 87       	std	Y+11, r25	; 0x0b
    1bbc:	eb 85       	ldd	r30, Y+11	; 0x0b
    1bbe:	ee 23       	and	r30, r30
    1bc0:	51 f7       	brne	.-44     	; 0x1b96 <handle_error+0x3a>
	Timer1_init(&timer_configurations);
    1bc2:	ce 01       	movw	r24, r28
    1bc4:	01 96       	adiw	r24, 0x01	; 1
    1bc6:	0e 94 77 0e 	call	0x1cee	; 0x1cee <Timer1_init>
	while(error);
    1bca:	80 91 89 00 	lds	r24, 0x0089
    1bce:	88 23       	and	r24, r24
    1bd0:	e1 f7       	brne	.-8      	; 0x1bca <handle_error+0x6e>
	Buzzer_off();
    1bd2:	0e 94 bb 05 	call	0xb76	; 0xb76 <Buzzer_off>
}
    1bd6:	2b 96       	adiw	r28, 0x0b	; 11
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	de bf       	out	0x3e, r29	; 62
    1bde:	0f be       	out	0x3f, r0	; 63
    1be0:	cd bf       	out	0x3d, r28	; 61
    1be2:	cf 91       	pop	r28
    1be4:	df 91       	pop	r29
    1be6:	08 95       	ret

00001be8 <DcMotor_Init>:
 * Description
 The Function responsible for setup the direction for the two
   motor pins through the GPIO driver.
 Stop at the DC-Motor at the beginning through the GPIO driver
 */
void DcMotor_Init(void){
    1be8:	df 93       	push	r29
    1bea:	cf 93       	push	r28
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62

	/*
	 * setup the direction of the two pins of the motor and stop the motor initially
	 */
	GPIO_setupPinDirection(MOTOR_PIN1_PORT_ID,MOTOR_PIN1_PIN_ID,PIN_OUTPUT);
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	60 e0       	ldi	r22, 0x00	; 0
    1bf4:	41 e0       	ldi	r20, 0x01	; 1
    1bf6:	0e 94 68 06 	call	0xcd0	; 0xcd0 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(MOTOR_PIN2_PORT_ID,MOTOR_PIN2_PIN_ID,PIN_OUTPUT);
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
    1bfc:	61 e0       	ldi	r22, 0x01	; 1
    1bfe:	41 e0       	ldi	r20, 0x01	; 1
    1c00:	0e 94 68 06 	call	0xcd0	; 0xcd0 <GPIO_setupPinDirection>
	GPIO_writePin(MOTOR_PIN1_PORT_ID,MOTOR_PIN1_PIN_ID,LOGIC_LOW);
    1c04:	81 e0       	ldi	r24, 0x01	; 1
    1c06:	60 e0       	ldi	r22, 0x00	; 0
    1c08:	40 e0       	ldi	r20, 0x00	; 0
    1c0a:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
	GPIO_writePin(MOTOR_PIN2_PORT_ID,MOTOR_PIN2_PIN_ID,LOGIC_LOW);
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	61 e0       	ldi	r22, 0x01	; 1
    1c12:	40 e0       	ldi	r20, 0x00	; 0
    1c14:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>



}
    1c18:	cf 91       	pop	r28
    1c1a:	df 91       	pop	r29
    1c1c:	08 95       	ret

00001c1e <DcMotor_Rotate>:
 Send the required duty cycle to the PWM driver based on the
      required speed value.
 */


void DcMotor_Rotate(DcMotor_State state,uint8 speed){
    1c1e:	df 93       	push	r29
    1c20:	cf 93       	push	r28
    1c22:	00 d0       	rcall	.+0      	; 0x1c24 <DcMotor_Rotate+0x6>
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    1c28:	89 83       	std	Y+1, r24	; 0x01
    1c2a:	6a 83       	std	Y+2, r22	; 0x02
	// initialize the enable pin of the motor that controls the speed to timer 0 pwm pin OC0
	PWM_Timer0_Start(speed);
    1c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c2e:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <PWM_Timer0_Start>
	if  (state == STOP){
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	82 30       	cpi	r24, 0x02	; 2
    1c36:	59 f4       	brne	.+22     	; 0x1c4e <DcMotor_Rotate+0x30>

		// Write the two pins that are connected to the motor to logic zero to stop the motor
		GPIO_writePin(MOTOR_PIN1_PORT_ID,MOTOR_PIN1_PIN_ID,LOGIC_LOW);
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	40 e0       	ldi	r20, 0x00	; 0
    1c3e:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
		GPIO_writePin(MOTOR_PIN2_PORT_ID,MOTOR_PIN2_PIN_ID,LOGIC_LOW);
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	61 e0       	ldi	r22, 0x01	; 1
    1c46:	40 e0       	ldi	r20, 0x00	; 0
    1c48:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
    1c4c:	1b c0       	rjmp	.+54     	; 0x1c84 <DcMotor_Rotate+0x66>
	}
	else if (state == CW){
    1c4e:	89 81       	ldd	r24, Y+1	; 0x01
    1c50:	88 23       	and	r24, r24
    1c52:	59 f4       	brne	.+22     	; 0x1c6a <DcMotor_Rotate+0x4c>
		/*
		 * write the first pin to logic low and the second
		 * write the second pin to logic high to
		 * the motor rotates clock wise
		 */
		GPIO_writePin(MOTOR_PIN1_PORT_ID,MOTOR_PIN1_PIN_ID,LOGIC_LOW);
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	60 e0       	ldi	r22, 0x00	; 0
    1c58:	40 e0       	ldi	r20, 0x00	; 0
    1c5a:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
		GPIO_writePin(MOTOR_PIN2_PORT_ID,MOTOR_PIN2_PIN_ID,LOGIC_HIGH);
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	61 e0       	ldi	r22, 0x01	; 1
    1c62:	41 e0       	ldi	r20, 0x01	; 1
    1c64:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
    1c68:	0d c0       	rjmp	.+26     	; 0x1c84 <DcMotor_Rotate+0x66>

	}
	else if (state ==A_CW){
    1c6a:	89 81       	ldd	r24, Y+1	; 0x01
    1c6c:	81 30       	cpi	r24, 0x01	; 1
    1c6e:	51 f4       	brne	.+20     	; 0x1c84 <DcMotor_Rotate+0x66>
		/*
		 * write the first pin to logic high and the second
		 * write the second pin to logic low
		 * the  motor rotates anti clock wise
		*/
		GPIO_writePin(MOTOR_PIN1_PORT_ID,MOTOR_PIN1_PIN_ID,LOGIC_HIGH);
    1c70:	81 e0       	ldi	r24, 0x01	; 1
    1c72:	60 e0       	ldi	r22, 0x00	; 0
    1c74:	41 e0       	ldi	r20, 0x01	; 1
    1c76:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>
		GPIO_writePin(MOTOR_PIN2_PORT_ID,MOTOR_PIN2_PIN_ID,LOGIC_LOW);
    1c7a:	81 e0       	ldi	r24, 0x01	; 1
    1c7c:	61 e0       	ldi	r22, 0x01	; 1
    1c7e:	40 e0       	ldi	r20, 0x00	; 0
    1c80:	0e 94 53 07 	call	0xea6	; 0xea6 <GPIO_writePin>

	}

}
    1c84:	0f 90       	pop	r0
    1c86:	0f 90       	pop	r0
    1c88:	cf 91       	pop	r28
    1c8a:	df 91       	pop	r29
    1c8c:	08 95       	ret

00001c8e <PWM_Timer0_Start>:
    Setup the compare value based on the required input duty cycle
    Setup the direction for OC0 as output pin through the GPIO driver.
    The generated PWM signal frequency will be 500Hz to control the DC
       Motor speed
 */
void PWM_Timer0_Start(uint8 duty_cycle){
    1c8e:	df 93       	push	r29
    1c90:	cf 93       	push	r28
    1c92:	0f 92       	push	r0
    1c94:	cd b7       	in	r28, 0x3d	; 61
    1c96:	de b7       	in	r29, 0x3e	; 62
    1c98:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * setup the pwm_mode  and the frequency of the timer
	 */
	TCCR0 = (1<<WGM01)|(1<<WGM00)|(1<<COM01)|(1<<CS01);
    1c9a:	e3 e5       	ldi	r30, 0x53	; 83
    1c9c:	f0 e0       	ldi	r31, 0x00	; 0
    1c9e:	8a e6       	ldi	r24, 0x6A	; 106
    1ca0:	80 83       	st	Z, r24

	/*
	 * setup the pin OC0 as output to put the pwm on it
	 */
	GPIO_setupPinDirection(PWM_PORT_ID , PWM_PIN_ID,PIN_OUTPUT);
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	63 e0       	ldi	r22, 0x03	; 3
    1ca6:	41 e0       	ldi	r20, 0x01	; 1
    1ca8:	0e 94 68 06 	call	0xcd0	; 0xcd0 <GPIO_setupPinDirection>
	TCNT0 = 0;
    1cac:	e2 e5       	ldi	r30, 0x52	; 82
    1cae:	f0 e0       	ldi	r31, 0x00	; 0
    1cb0:	10 82       	st	Z, r1
	OCR0  = 255 * duty_cycle / 100  ;
    1cb2:	ec e5       	ldi	r30, 0x5C	; 92
    1cb4:	f0 e0       	ldi	r31, 0x00	; 0
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	48 2f       	mov	r20, r24
    1cba:	50 e0       	ldi	r21, 0x00	; 0
    1cbc:	ca 01       	movw	r24, r20
    1cbe:	9c 01       	movw	r18, r24
    1cc0:	22 0f       	add	r18, r18
    1cc2:	33 1f       	adc	r19, r19
    1cc4:	c9 01       	movw	r24, r18
    1cc6:	96 95       	lsr	r25
    1cc8:	98 2f       	mov	r25, r24
    1cca:	88 27       	eor	r24, r24
    1ccc:	97 95       	ror	r25
    1cce:	87 95       	ror	r24
    1cd0:	82 1b       	sub	r24, r18
    1cd2:	93 0b       	sbc	r25, r19
    1cd4:	84 0f       	add	r24, r20
    1cd6:	95 1f       	adc	r25, r21
    1cd8:	24 e6       	ldi	r18, 0x64	; 100
    1cda:	30 e0       	ldi	r19, 0x00	; 0
    1cdc:	b9 01       	movw	r22, r18
    1cde:	0e 94 42 11 	call	0x2284	; 0x2284 <__divmodhi4>
    1ce2:	cb 01       	movw	r24, r22
    1ce4:	80 83       	st	Z, r24





}
    1ce6:	0f 90       	pop	r0
    1ce8:	cf 91       	pop	r28
    1cea:	df 91       	pop	r29
    1cec:	08 95       	ret

00001cee <Timer1_init>:
/************************  Global variables *********************************/

static volatile void (*g_callBackPtr)(void) = NULL_PTR;
/***********************     functions      ************************************/

void Timer1_init(const Timer1_ConfigType* Config_Ptr){
    1cee:	df 93       	push	r29
    1cf0:	cf 93       	push	r28
    1cf2:	00 d0       	rcall	.+0      	; 0x1cf4 <Timer1_init+0x6>
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
    1cf8:	9a 83       	std	Y+2, r25	; 0x02
    1cfa:	89 83       	std	Y+1, r24	; 0x01

	/* Timer1 always operates in Normal Mode */
	TCCR1A = (1<<FOC1A) | (1<<FOC1B);
    1cfc:	ef e4       	ldi	r30, 0x4F	; 79
    1cfe:	f0 e0       	ldi	r31, 0x00	; 0
    1d00:	8c e0       	ldi	r24, 0x0C	; 12
    1d02:	80 83       	st	Z, r24

	TCCR1B =Config_Ptr -> prescaler  ;  // configure the prescaler of the timer
    1d04:	ae e4       	ldi	r26, 0x4E	; 78
    1d06:	b0 e0       	ldi	r27, 0x00	; 0
    1d08:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0c:	84 81       	ldd	r24, Z+4	; 0x04
    1d0e:	8c 93       	st	X, r24
	if (Config_Ptr -> mode == NORMAL){
    1d10:	e9 81       	ldd	r30, Y+1	; 0x01
    1d12:	fa 81       	ldd	r31, Y+2	; 0x02
    1d14:	85 81       	ldd	r24, Z+5	; 0x05
    1d16:	88 23       	and	r24, r24
    1d18:	21 f5       	brne	.+72     	; 0x1d62 <Timer1_init+0x74>

		// Modify The Bits of The normal mode  WGM10=0 , WGM11=0, WGM12=0 , WGM13=0
		CLEAR_BIT(TCCR1A,WGM10);
    1d1a:	af e4       	ldi	r26, 0x4F	; 79
    1d1c:	b0 e0       	ldi	r27, 0x00	; 0
    1d1e:	ef e4       	ldi	r30, 0x4F	; 79
    1d20:	f0 e0       	ldi	r31, 0x00	; 0
    1d22:	80 81       	ld	r24, Z
    1d24:	8e 7f       	andi	r24, 0xFE	; 254
    1d26:	8c 93       	st	X, r24
		CLEAR_BIT(TCCR1A,WGM11);
    1d28:	af e4       	ldi	r26, 0x4F	; 79
    1d2a:	b0 e0       	ldi	r27, 0x00	; 0
    1d2c:	ef e4       	ldi	r30, 0x4F	; 79
    1d2e:	f0 e0       	ldi	r31, 0x00	; 0
    1d30:	80 81       	ld	r24, Z
    1d32:	8d 7f       	andi	r24, 0xFD	; 253
    1d34:	8c 93       	st	X, r24
		CLEAR_BIT(TCCR1B,WGM12);
    1d36:	ae e4       	ldi	r26, 0x4E	; 78
    1d38:	b0 e0       	ldi	r27, 0x00	; 0
    1d3a:	ee e4       	ldi	r30, 0x4E	; 78
    1d3c:	f0 e0       	ldi	r31, 0x00	; 0
    1d3e:	80 81       	ld	r24, Z
    1d40:	87 7f       	andi	r24, 0xF7	; 247
    1d42:	8c 93       	st	X, r24
		CLEAR_BIT(TCCR1B,WGM13);
    1d44:	ae e4       	ldi	r26, 0x4E	; 78
    1d46:	b0 e0       	ldi	r27, 0x00	; 0
    1d48:	ee e4       	ldi	r30, 0x4E	; 78
    1d4a:	f0 e0       	ldi	r31, 0x00	; 0
    1d4c:	80 81       	ld	r24, Z
    1d4e:	8f 7e       	andi	r24, 0xEF	; 239
    1d50:	8c 93       	st	X, r24
		// enable the interrupt of the overflow mode
		SET_BIT(TIMSK ,TOIE1);
    1d52:	a9 e5       	ldi	r26, 0x59	; 89
    1d54:	b0 e0       	ldi	r27, 0x00	; 0
    1d56:	e9 e5       	ldi	r30, 0x59	; 89
    1d58:	f0 e0       	ldi	r31, 0x00	; 0
    1d5a:	80 81       	ld	r24, Z
    1d5c:	84 60       	ori	r24, 0x04	; 4
    1d5e:	8c 93       	st	X, r24
    1d60:	31 c0       	rjmp	.+98     	; 0x1dc4 <Timer1_init+0xd6>
	}
	else if (Config_Ptr -> mode == CTC){
    1d62:	e9 81       	ldd	r30, Y+1	; 0x01
    1d64:	fa 81       	ldd	r31, Y+2	; 0x02
    1d66:	85 81       	ldd	r24, Z+5	; 0x05
    1d68:	81 30       	cpi	r24, 0x01	; 1
    1d6a:	61 f5       	brne	.+88     	; 0x1dc4 <Timer1_init+0xd6>
		// Modify The Bits of the normal mode  WGM10=0 ,WGM11=0 ,WGM12=1 , WGM13=0
		CLEAR_BIT(TCCR1A,WGM10);
    1d6c:	af e4       	ldi	r26, 0x4F	; 79
    1d6e:	b0 e0       	ldi	r27, 0x00	; 0
    1d70:	ef e4       	ldi	r30, 0x4F	; 79
    1d72:	f0 e0       	ldi	r31, 0x00	; 0
    1d74:	80 81       	ld	r24, Z
    1d76:	8e 7f       	andi	r24, 0xFE	; 254
    1d78:	8c 93       	st	X, r24
		CLEAR_BIT(TCCR1A,WGM11);
    1d7a:	af e4       	ldi	r26, 0x4F	; 79
    1d7c:	b0 e0       	ldi	r27, 0x00	; 0
    1d7e:	ef e4       	ldi	r30, 0x4F	; 79
    1d80:	f0 e0       	ldi	r31, 0x00	; 0
    1d82:	80 81       	ld	r24, Z
    1d84:	8d 7f       	andi	r24, 0xFD	; 253
    1d86:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
    1d88:	ae e4       	ldi	r26, 0x4E	; 78
    1d8a:	b0 e0       	ldi	r27, 0x00	; 0
    1d8c:	ee e4       	ldi	r30, 0x4E	; 78
    1d8e:	f0 e0       	ldi	r31, 0x00	; 0
    1d90:	80 81       	ld	r24, Z
    1d92:	88 60       	ori	r24, 0x08	; 8
    1d94:	8c 93       	st	X, r24
		CLEAR_BIT(TCCR1B,WGM13);
    1d96:	ae e4       	ldi	r26, 0x4E	; 78
    1d98:	b0 e0       	ldi	r27, 0x00	; 0
    1d9a:	ee e4       	ldi	r30, 0x4E	; 78
    1d9c:	f0 e0       	ldi	r31, 0x00	; 0
    1d9e:	80 81       	ld	r24, Z
    1da0:	8f 7e       	andi	r24, 0xEF	; 239
    1da2:	8c 93       	st	X, r24
		// enable the interrupt of the compare on outpput compare register A
		SET_BIT (TIMSK ,OCIE1A);
    1da4:	a9 e5       	ldi	r26, 0x59	; 89
    1da6:	b0 e0       	ldi	r27, 0x00	; 0
    1da8:	e9 e5       	ldi	r30, 0x59	; 89
    1daa:	f0 e0       	ldi	r31, 0x00	; 0
    1dac:	80 81       	ld	r24, Z
    1dae:	80 61       	ori	r24, 0x10	; 16
    1db0:	8c 93       	st	X, r24
		OCR1A = Config_Ptr -> compare_value;
    1db2:	aa e4       	ldi	r26, 0x4A	; 74
    1db4:	b0 e0       	ldi	r27, 0x00	; 0
    1db6:	e9 81       	ldd	r30, Y+1	; 0x01
    1db8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dba:	82 81       	ldd	r24, Z+2	; 0x02
    1dbc:	93 81       	ldd	r25, Z+3	; 0x03
    1dbe:	11 96       	adiw	r26, 0x01	; 1
    1dc0:	9c 93       	st	X, r25
    1dc2:	8e 93       	st	-X, r24

	}


	TCNT1 = Config_Ptr ->initial_value; // insert the initial value in the timer counter register
    1dc4:	ec e4       	ldi	r30, 0x4C	; 76
    1dc6:	f0 e0       	ldi	r31, 0x00	; 0
    1dc8:	a9 81       	ldd	r26, Y+1	; 0x01
    1dca:	ba 81       	ldd	r27, Y+2	; 0x02
    1dcc:	8d 91       	ld	r24, X+
    1dce:	9c 91       	ld	r25, X
    1dd0:	11 97       	sbiw	r26, 0x01	; 1
    1dd2:	91 83       	std	Z+1, r25	; 0x01
    1dd4:	80 83       	st	Z, r24




}
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	cf 91       	pop	r28
    1ddc:	df 91       	pop	r29
    1dde:	08 95       	ret

00001de0 <Timer1_deInit>:
          Timer1_ConfigType.
     Return: None
 */


void Timer1_deInit(void){
    1de0:	df 93       	push	r29
    1de2:	cf 93       	push	r28
    1de4:	cd b7       	in	r28, 0x3d	; 61
    1de6:	de b7       	in	r29, 0x3e	; 62
	/* Clear All Timer1/ICU Registers */
	TCCR1A = 0;
    1de8:	ef e4       	ldi	r30, 0x4F	; 79
    1dea:	f0 e0       	ldi	r31, 0x00	; 0
    1dec:	10 82       	st	Z, r1
	TCCR1B = 0;
    1dee:	ee e4       	ldi	r30, 0x4E	; 78
    1df0:	f0 e0       	ldi	r31, 0x00	; 0
    1df2:	10 82       	st	Z, r1
	TCNT1 = 0;
    1df4:	ec e4       	ldi	r30, 0x4C	; 76
    1df6:	f0 e0       	ldi	r31, 0x00	; 0
    1df8:	11 82       	std	Z+1, r1	; 0x01
    1dfa:	10 82       	st	Z, r1
	ICR1 = 0;
    1dfc:	e6 e4       	ldi	r30, 0x46	; 70
    1dfe:	f0 e0       	ldi	r31, 0x00	; 0
    1e00:	11 82       	std	Z+1, r1	; 0x01
    1e02:	10 82       	st	Z, r1
	TIMSK=0;
    1e04:	e9 e5       	ldi	r30, 0x59	; 89
    1e06:	f0 e0       	ldi	r31, 0x00	; 0
    1e08:	10 82       	st	Z, r1
	/* Reset the global pointer value */
	g_callBackPtr = NULL_PTR;
    1e0a:	10 92 8c 00 	sts	0x008C, r1
    1e0e:	10 92 8b 00 	sts	0x008B, r1




}
    1e12:	cf 91       	pop	r28
    1e14:	df 91       	pop	r29
    1e16:	08 95       	ret

00001e18 <Timer1_setCallBack>:
          Function to disable the Timer1.
    Inputs: None
    Return: None
 */

void Timer1_setCallBack(void(*a_ptr)(void)){
    1e18:	df 93       	push	r29
    1e1a:	cf 93       	push	r28
    1e1c:	00 d0       	rcall	.+0      	; 0x1e1e <Timer1_setCallBack+0x6>
    1e1e:	cd b7       	in	r28, 0x3d	; 61
    1e20:	de b7       	in	r29, 0x3e	; 62
    1e22:	9a 83       	std	Y+2, r25	; 0x02
    1e24:	89 83       	std	Y+1, r24	; 0x01

	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr  ;
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	9a 81       	ldd	r25, Y+2	; 0x02
    1e2a:	90 93 8c 00 	sts	0x008C, r25
    1e2e:	80 93 8b 00 	sts	0x008B, r24


}
    1e32:	0f 90       	pop	r0
    1e34:	0f 90       	pop	r0
    1e36:	cf 91       	pop	r28
    1e38:	df 91       	pop	r29
    1e3a:	08 95       	ret

00001e3c <__vector_9>:
    Inputs: pointer to Call Back function.
    Return: None
 */


ISR (TIMER1_OVF_vect){
    1e3c:	1f 92       	push	r1
    1e3e:	0f 92       	push	r0
    1e40:	0f b6       	in	r0, 0x3f	; 63
    1e42:	0f 92       	push	r0
    1e44:	11 24       	eor	r1, r1
    1e46:	2f 93       	push	r18
    1e48:	3f 93       	push	r19
    1e4a:	4f 93       	push	r20
    1e4c:	5f 93       	push	r21
    1e4e:	6f 93       	push	r22
    1e50:	7f 93       	push	r23
    1e52:	8f 93       	push	r24
    1e54:	9f 93       	push	r25
    1e56:	af 93       	push	r26
    1e58:	bf 93       	push	r27
    1e5a:	ef 93       	push	r30
    1e5c:	ff 93       	push	r31
    1e5e:	df 93       	push	r29
    1e60:	cf 93       	push	r28
    1e62:	cd b7       	in	r28, 0x3d	; 61
    1e64:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
    1e66:	80 91 8b 00 	lds	r24, 0x008B
    1e6a:	90 91 8c 00 	lds	r25, 0x008C
    1e6e:	00 97       	sbiw	r24, 0x00	; 0
    1e70:	29 f0       	breq	.+10     	; 0x1e7c <__vector_9+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    1e72:	e0 91 8b 00 	lds	r30, 0x008B
    1e76:	f0 91 8c 00 	lds	r31, 0x008C
    1e7a:	09 95       	icall
	}
}
    1e7c:	cf 91       	pop	r28
    1e7e:	df 91       	pop	r29
    1e80:	ff 91       	pop	r31
    1e82:	ef 91       	pop	r30
    1e84:	bf 91       	pop	r27
    1e86:	af 91       	pop	r26
    1e88:	9f 91       	pop	r25
    1e8a:	8f 91       	pop	r24
    1e8c:	7f 91       	pop	r23
    1e8e:	6f 91       	pop	r22
    1e90:	5f 91       	pop	r21
    1e92:	4f 91       	pop	r20
    1e94:	3f 91       	pop	r19
    1e96:	2f 91       	pop	r18
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63
    1e9c:	0f 90       	pop	r0
    1e9e:	1f 90       	pop	r1
    1ea0:	18 95       	reti

00001ea2 <__vector_7>:



ISR (TIMER1_COMPA_vect){
    1ea2:	1f 92       	push	r1
    1ea4:	0f 92       	push	r0
    1ea6:	0f b6       	in	r0, 0x3f	; 63
    1ea8:	0f 92       	push	r0
    1eaa:	11 24       	eor	r1, r1
    1eac:	2f 93       	push	r18
    1eae:	3f 93       	push	r19
    1eb0:	4f 93       	push	r20
    1eb2:	5f 93       	push	r21
    1eb4:	6f 93       	push	r22
    1eb6:	7f 93       	push	r23
    1eb8:	8f 93       	push	r24
    1eba:	9f 93       	push	r25
    1ebc:	af 93       	push	r26
    1ebe:	bf 93       	push	r27
    1ec0:	ef 93       	push	r30
    1ec2:	ff 93       	push	r31
    1ec4:	df 93       	push	r29
    1ec6:	cf 93       	push	r28
    1ec8:	cd b7       	in	r28, 0x3d	; 61
    1eca:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
    1ecc:	80 91 8b 00 	lds	r24, 0x008B
    1ed0:	90 91 8c 00 	lds	r25, 0x008C
    1ed4:	00 97       	sbiw	r24, 0x00	; 0
    1ed6:	29 f0       	breq	.+10     	; 0x1ee2 <__vector_7+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    1ed8:	e0 91 8b 00 	lds	r30, 0x008B
    1edc:	f0 91 8c 00 	lds	r31, 0x008C
    1ee0:	09 95       	icall
	}
}
    1ee2:	cf 91       	pop	r28
    1ee4:	df 91       	pop	r29
    1ee6:	ff 91       	pop	r31
    1ee8:	ef 91       	pop	r30
    1eea:	bf 91       	pop	r27
    1eec:	af 91       	pop	r26
    1eee:	9f 91       	pop	r25
    1ef0:	8f 91       	pop	r24
    1ef2:	7f 91       	pop	r23
    1ef4:	6f 91       	pop	r22
    1ef6:	5f 91       	pop	r21
    1ef8:	4f 91       	pop	r20
    1efa:	3f 91       	pop	r19
    1efc:	2f 91       	pop	r18
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	0f 90       	pop	r0
    1f04:	1f 90       	pop	r1
    1f06:	18 95       	reti

00001f08 <TWI_init>:
#include "twi.h"
#include "common_macros.h"
#include <avr/io.h>

void TWI_init(const TWI_ConfigType * Config_Ptr)
{
    1f08:	df 93       	push	r29
    1f0a:	cf 93       	push	r28
    1f0c:	00 d0       	rcall	.+0      	; 0x1f0e <TWI_init+0x6>
    1f0e:	cd b7       	in	r28, 0x3d	; 61
    1f10:	de b7       	in	r29, 0x3e	; 62
    1f12:	9a 83       	std	Y+2, r25	; 0x02
    1f14:	89 83       	std	Y+1, r24	; 0x01
    /*modify bit rate according to the config_ptr bit_rate value*/
    TWBR = Config_Ptr->bit_rate;
    1f16:	a0 e2       	ldi	r26, 0x20	; 32
    1f18:	b0 e0       	ldi	r27, 0x00	; 0
    1f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1e:	81 81       	ldd	r24, Z+1	; 0x01
    1f20:	8c 93       	st	X, r24
    /*using zero pre-scaler TWPS=00 and F_CPU=8Mhz */
	TWSR = 0x00;
    1f22:	e1 e2       	ldi	r30, 0x21	; 33
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	10 82       	st	Z, r1
	
    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR =(Config_Ptr->address<<1); //
    1f28:	a2 e2       	ldi	r26, 0x22	; 34
    1f2a:	b0 e0       	ldi	r27, 0x00	; 0
    1f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f30:	80 81       	ld	r24, Z
    1f32:	88 0f       	add	r24, r24
    1f34:	8c 93       	st	X, r24
	
    TWCR = (1<<TWEN); /* enable TWI */
    1f36:	e6 e5       	ldi	r30, 0x56	; 86
    1f38:	f0 e0       	ldi	r31, 0x00	; 0
    1f3a:	84 e0       	ldi	r24, 0x04	; 4
    1f3c:	80 83       	st	Z, r24
}
    1f3e:	0f 90       	pop	r0
    1f40:	0f 90       	pop	r0
    1f42:	cf 91       	pop	r28
    1f44:	df 91       	pop	r29
    1f46:	08 95       	ret

00001f48 <TWI_start>:

void TWI_start(void)
{
    1f48:	df 93       	push	r29
    1f4a:	cf 93       	push	r28
    1f4c:	cd b7       	in	r28, 0x3d	; 61
    1f4e:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    1f50:	e6 e5       	ldi	r30, 0x56	; 86
    1f52:	f0 e0       	ldi	r31, 0x00	; 0
    1f54:	84 ea       	ldi	r24, 0xA4	; 164
    1f56:	80 83       	st	Z, r24
    
    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1f58:	e6 e5       	ldi	r30, 0x56	; 86
    1f5a:	f0 e0       	ldi	r31, 0x00	; 0
    1f5c:	80 81       	ld	r24, Z
    1f5e:	88 23       	and	r24, r24
    1f60:	dc f7       	brge	.-10     	; 0x1f58 <TWI_start+0x10>
}
    1f62:	cf 91       	pop	r28
    1f64:	df 91       	pop	r29
    1f66:	08 95       	ret

00001f68 <TWI_stop>:

void TWI_stop(void)
{
    1f68:	df 93       	push	r29
    1f6a:	cf 93       	push	r28
    1f6c:	cd b7       	in	r28, 0x3d	; 61
    1f6e:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    1f70:	e6 e5       	ldi	r30, 0x56	; 86
    1f72:	f0 e0       	ldi	r31, 0x00	; 0
    1f74:	84 e9       	ldi	r24, 0x94	; 148
    1f76:	80 83       	st	Z, r24
}
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	08 95       	ret

00001f7e <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
    1f7e:	df 93       	push	r29
    1f80:	cf 93       	push	r28
    1f82:	0f 92       	push	r0
    1f84:	cd b7       	in	r28, 0x3d	; 61
    1f86:	de b7       	in	r29, 0x3e	; 62
    1f88:	89 83       	std	Y+1, r24	; 0x01
    /* Put data On TWI data Register */
    TWDR = data;
    1f8a:	e3 e2       	ldi	r30, 0x23	; 35
    1f8c:	f0 e0       	ldi	r31, 0x00	; 0
    1f8e:	89 81       	ldd	r24, Y+1	; 0x01
    1f90:	80 83       	st	Z, r24
    /* 
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN);
    1f92:	e6 e5       	ldi	r30, 0x56	; 86
    1f94:	f0 e0       	ldi	r31, 0x00	; 0
    1f96:	84 e8       	ldi	r24, 0x84	; 132
    1f98:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1f9a:	e6 e5       	ldi	r30, 0x56	; 86
    1f9c:	f0 e0       	ldi	r31, 0x00	; 0
    1f9e:	80 81       	ld	r24, Z
    1fa0:	88 23       	and	r24, r24
    1fa2:	dc f7       	brge	.-10     	; 0x1f9a <TWI_writeByte+0x1c>
}
    1fa4:	0f 90       	pop	r0
    1fa6:	cf 91       	pop	r28
    1fa8:	df 91       	pop	r29
    1faa:	08 95       	ret

00001fac <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    1fac:	df 93       	push	r29
    1fae:	cf 93       	push	r28
    1fb0:	cd b7       	in	r28, 0x3d	; 61
    1fb2:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1fb4:	e6 e5       	ldi	r30, 0x56	; 86
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	84 ec       	ldi	r24, 0xC4	; 196
    1fba:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1fbc:	e6 e5       	ldi	r30, 0x56	; 86
    1fbe:	f0 e0       	ldi	r31, 0x00	; 0
    1fc0:	80 81       	ld	r24, Z
    1fc2:	88 23       	and	r24, r24
    1fc4:	dc f7       	brge	.-10     	; 0x1fbc <TWI_readByteWithACK+0x10>
    /* Read Data */
    return TWDR;
    1fc6:	e3 e2       	ldi	r30, 0x23	; 35
    1fc8:	f0 e0       	ldi	r31, 0x00	; 0
    1fca:	80 81       	ld	r24, Z
}
    1fcc:	cf 91       	pop	r28
    1fce:	df 91       	pop	r29
    1fd0:	08 95       	ret

00001fd2 <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    1fd2:	df 93       	push	r29
    1fd4:	cf 93       	push	r28
    1fd6:	cd b7       	in	r28, 0x3d	; 61
    1fd8:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    1fda:	e6 e5       	ldi	r30, 0x56	; 86
    1fdc:	f0 e0       	ldi	r31, 0x00	; 0
    1fde:	84 e8       	ldi	r24, 0x84	; 132
    1fe0:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1fe2:	e6 e5       	ldi	r30, 0x56	; 86
    1fe4:	f0 e0       	ldi	r31, 0x00	; 0
    1fe6:	80 81       	ld	r24, Z
    1fe8:	88 23       	and	r24, r24
    1fea:	dc f7       	brge	.-10     	; 0x1fe2 <TWI_readByteWithNACK+0x10>
    /* Read Data */
    return TWDR;
    1fec:	e3 e2       	ldi	r30, 0x23	; 35
    1fee:	f0 e0       	ldi	r31, 0x00	; 0
    1ff0:	80 81       	ld	r24, Z
}
    1ff2:	cf 91       	pop	r28
    1ff4:	df 91       	pop	r29
    1ff6:	08 95       	ret

00001ff8 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	0f 92       	push	r0
    1ffe:	cd b7       	in	r28, 0x3d	; 61
    2000:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;
    2002:	e1 e2       	ldi	r30, 0x21	; 33
    2004:	f0 e0       	ldi	r31, 0x00	; 0
    2006:	80 81       	ld	r24, Z
    2008:	88 7f       	andi	r24, 0xF8	; 248
    200a:	89 83       	std	Y+1, r24	; 0x01
    return status;
    200c:	89 81       	ldd	r24, Y+1	; 0x01
}
    200e:	0f 90       	pop	r0
    2010:	cf 91       	pop	r28
    2012:	df 91       	pop	r29
    2014:	08 95       	ret

00002016 <UART_init>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
    2016:	df 93       	push	r29
    2018:	cf 93       	push	r28
    201a:	00 d0       	rcall	.+0      	; 0x201c <UART_init+0x6>
    201c:	00 d0       	rcall	.+0      	; 0x201e <UART_init+0x8>
    201e:	cd b7       	in	r28, 0x3d	; 61
    2020:	de b7       	in	r29, 0x3e	; 62
    2022:	9c 83       	std	Y+4, r25	; 0x04
    2024:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0 ;
    2026:	1a 82       	std	Y+2, r1	; 0x02
    2028:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	UCSRA = (1<<U2X) ;
    202a:	eb e2       	ldi	r30, 0x2B	; 43
    202c:	f0 e0       	ldi	r31, 0x00	; 0
    202e:	82 e0       	ldi	r24, 0x02	; 2
    2030:	80 83       	st	Z, r24
	 * UDRIE = 0 Disable USART Data Register Empty Interrupt Enable
	 * RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 * UCSZ2 = 1  For 9-bit data mode ONLY
	 ***********************************************************************/ 
	UCSRB = (1<<RXEN) | (1<<TXEN);
    2032:	ea e2       	ldi	r30, 0x2A	; 42
    2034:	f0 e0       	ldi	r31, 0x00	; 0
    2036:	88 e1       	ldi	r24, 0x18	; 24
    2038:	80 83       	st	Z, r24
	if (Config_Ptr -> bit_data == NINE_BITS){
    203a:	eb 81       	ldd	r30, Y+3	; 0x03
    203c:	fc 81       	ldd	r31, Y+4	; 0x04
    203e:	80 81       	ld	r24, Z
    2040:	87 30       	cpi	r24, 0x07	; 7
    2042:	39 f4       	brne	.+14     	; 0x2052 <UART_init+0x3c>
		UCSRB |= (1<<UCSZ2);
    2044:	aa e2       	ldi	r26, 0x2A	; 42
    2046:	b0 e0       	ldi	r27, 0x00	; 0
    2048:	ea e2       	ldi	r30, 0x2A	; 42
    204a:	f0 e0       	ldi	r31, 0x00	; 0
    204c:	80 81       	ld	r24, Z
    204e:	84 60       	ori	r24, 0x04	; 4
    2050:	8c 93       	st	X, r24
	 * USBS    = 0 One stop bit
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 ***********************************************************************/
	/* configure UCSZ1:0 TO choose the data bits */
    if (Config_Ptr ->bit_data == FIVE_BITS){
    2052:	eb 81       	ldd	r30, Y+3	; 0x03
    2054:	fc 81       	ldd	r31, Y+4	; 0x04
    2056:	80 81       	ld	r24, Z
    2058:	88 23       	and	r24, r24
    205a:	29 f4       	brne	.+10     	; 0x2066 <UART_init+0x50>
    	UCSRC =(1<<URSEL);
    205c:	e0 e4       	ldi	r30, 0x40	; 64
    205e:	f0 e0       	ldi	r31, 0x00	; 0
    2060:	80 e8       	ldi	r24, 0x80	; 128
    2062:	80 83       	st	Z, r24
    2064:	22 c0       	rjmp	.+68     	; 0x20aa <UART_init+0x94>
    }
    else if (Config_Ptr ->bit_data == SIX_BITS){
    2066:	eb 81       	ldd	r30, Y+3	; 0x03
    2068:	fc 81       	ldd	r31, Y+4	; 0x04
    206a:	80 81       	ld	r24, Z
    206c:	81 30       	cpi	r24, 0x01	; 1
    206e:	29 f4       	brne	.+10     	; 0x207a <UART_init+0x64>
    	UCSRC = (1<<URSEL) | (1<<UCSZ0);
    2070:	e0 e4       	ldi	r30, 0x40	; 64
    2072:	f0 e0       	ldi	r31, 0x00	; 0
    2074:	82 e8       	ldi	r24, 0x82	; 130
    2076:	80 83       	st	Z, r24
    2078:	18 c0       	rjmp	.+48     	; 0x20aa <UART_init+0x94>
    }
    else if (Config_Ptr ->bit_data == SEVEN_BITS){
    207a:	eb 81       	ldd	r30, Y+3	; 0x03
    207c:	fc 81       	ldd	r31, Y+4	; 0x04
    207e:	80 81       	ld	r24, Z
    2080:	82 30       	cpi	r24, 0x02	; 2
    2082:	29 f4       	brne	.+10     	; 0x208e <UART_init+0x78>
    	UCSRC = (1<<URSEL) | (1<<UCSZ1);
    2084:	e0 e4       	ldi	r30, 0x40	; 64
    2086:	f0 e0       	ldi	r31, 0x00	; 0
    2088:	84 e8       	ldi	r24, 0x84	; 132
    208a:	80 83       	st	Z, r24
    208c:	0e c0       	rjmp	.+28     	; 0x20aa <UART_init+0x94>
    }
    else if (Config_Ptr ->bit_data == EIGHT_BITS || Config_Ptr ->bit_data==NINE_BITS){
    208e:	eb 81       	ldd	r30, Y+3	; 0x03
    2090:	fc 81       	ldd	r31, Y+4	; 0x04
    2092:	80 81       	ld	r24, Z
    2094:	83 30       	cpi	r24, 0x03	; 3
    2096:	29 f0       	breq	.+10     	; 0x20a2 <UART_init+0x8c>
    2098:	eb 81       	ldd	r30, Y+3	; 0x03
    209a:	fc 81       	ldd	r31, Y+4	; 0x04
    209c:	80 81       	ld	r24, Z
    209e:	87 30       	cpi	r24, 0x07	; 7
    20a0:	21 f4       	brne	.+8      	; 0x20aa <UART_init+0x94>
    	UCSRC = (1<<URSEL) | (1<<UCSZ0) | (1<<UCSZ1) ;
    20a2:	e0 e4       	ldi	r30, 0x40	; 64
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	86 e8       	ldi	r24, 0x86	; 134
    20a8:	80 83       	st	Z, r24

    }

    /* configure the UPM1:0 to configure the parity mode */
    UCSRC |= (1<<URSEL) | (Config_Ptr ->parity <<4);
    20aa:	a0 e4       	ldi	r26, 0x40	; 64
    20ac:	b0 e0       	ldi	r27, 0x00	; 0
    20ae:	e0 e4       	ldi	r30, 0x40	; 64
    20b0:	f0 e0       	ldi	r31, 0x00	; 0
    20b2:	80 81       	ld	r24, Z
    20b4:	28 2f       	mov	r18, r24
    20b6:	eb 81       	ldd	r30, Y+3	; 0x03
    20b8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ba:	81 81       	ldd	r24, Z+1	; 0x01
    20bc:	88 2f       	mov	r24, r24
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	82 95       	swap	r24
    20c2:	92 95       	swap	r25
    20c4:	90 7f       	andi	r25, 0xF0	; 240
    20c6:	98 27       	eor	r25, r24
    20c8:	80 7f       	andi	r24, 0xF0	; 240
    20ca:	98 27       	eor	r25, r24
    20cc:	80 68       	ori	r24, 0x80	; 128
    20ce:	82 2b       	or	r24, r18
    20d0:	8c 93       	st	X, r24


    /* configure the USBS to choose the number of stop bits */
    UCSRC |= (1<<URSEL) | (Config_Ptr ->stop_bit << 3);
    20d2:	a0 e4       	ldi	r26, 0x40	; 64
    20d4:	b0 e0       	ldi	r27, 0x00	; 0
    20d6:	e0 e4       	ldi	r30, 0x40	; 64
    20d8:	f0 e0       	ldi	r31, 0x00	; 0
    20da:	80 81       	ld	r24, Z
    20dc:	28 2f       	mov	r18, r24
    20de:	eb 81       	ldd	r30, Y+3	; 0x03
    20e0:	fc 81       	ldd	r31, Y+4	; 0x04
    20e2:	82 81       	ldd	r24, Z+2	; 0x02
    20e4:	88 2f       	mov	r24, r24
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	88 0f       	add	r24, r24
    20ea:	99 1f       	adc	r25, r25
    20ec:	88 0f       	add	r24, r24
    20ee:	99 1f       	adc	r25, r25
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	80 68       	ori	r24, 0x80	; 128
    20f6:	82 2b       	or	r24, r18
    20f8:	8c 93       	st	X, r24
	
	/* Calculate the UBRR register value */
	ubrr_value = (uint16)(((F_CPU / (Config_Ptr ->baud_rate * 8UL))) - 1) ;
    20fa:	eb 81       	ldd	r30, Y+3	; 0x03
    20fc:	fc 81       	ldd	r31, Y+4	; 0x04
    20fe:	83 81       	ldd	r24, Z+3	; 0x03
    2100:	94 81       	ldd	r25, Z+4	; 0x04
    2102:	a5 81       	ldd	r26, Z+5	; 0x05
    2104:	b6 81       	ldd	r27, Z+6	; 0x06
    2106:	88 0f       	add	r24, r24
    2108:	99 1f       	adc	r25, r25
    210a:	aa 1f       	adc	r26, r26
    210c:	bb 1f       	adc	r27, r27
    210e:	88 0f       	add	r24, r24
    2110:	99 1f       	adc	r25, r25
    2112:	aa 1f       	adc	r26, r26
    2114:	bb 1f       	adc	r27, r27
    2116:	88 0f       	add	r24, r24
    2118:	99 1f       	adc	r25, r25
    211a:	aa 1f       	adc	r26, r26
    211c:	bb 1f       	adc	r27, r27
    211e:	9c 01       	movw	r18, r24
    2120:	ad 01       	movw	r20, r26
    2122:	80 e0       	ldi	r24, 0x00	; 0
    2124:	92 e1       	ldi	r25, 0x12	; 18
    2126:	aa e7       	ldi	r26, 0x7A	; 122
    2128:	b0 e0       	ldi	r27, 0x00	; 0
    212a:	bc 01       	movw	r22, r24
    212c:	cd 01       	movw	r24, r26
    212e:	0e 94 55 11 	call	0x22aa	; 0x22aa <__udivmodsi4>
    2132:	da 01       	movw	r26, r20
    2134:	c9 01       	movw	r24, r18
    2136:	01 97       	sbiw	r24, 0x01	; 1
    2138:	9a 83       	std	Y+2, r25	; 0x02
    213a:	89 83       	std	Y+1, r24	; 0x01

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value>>8;
    213c:	e0 e4       	ldi	r30, 0x40	; 64
    213e:	f0 e0       	ldi	r31, 0x00	; 0
    2140:	89 81       	ldd	r24, Y+1	; 0x01
    2142:	9a 81       	ldd	r25, Y+2	; 0x02
    2144:	89 2f       	mov	r24, r25
    2146:	99 27       	eor	r25, r25
    2148:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
    214a:	e9 e2       	ldi	r30, 0x29	; 41
    214c:	f0 e0       	ldi	r31, 0x00	; 0
    214e:	89 81       	ldd	r24, Y+1	; 0x01
    2150:	80 83       	st	Z, r24
}
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	0f 90       	pop	r0
    2158:	0f 90       	pop	r0
    215a:	cf 91       	pop	r28
    215c:	df 91       	pop	r29
    215e:	08 95       	ret

00002160 <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
    2160:	df 93       	push	r29
    2162:	cf 93       	push	r28
    2164:	0f 92       	push	r0
    2166:	cd b7       	in	r28, 0x3d	; 61
    2168:	de b7       	in	r29, 0x3e	; 62
    216a:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
    216c:	eb e2       	ldi	r30, 0x2B	; 43
    216e:	f0 e0       	ldi	r31, 0x00	; 0
    2170:	80 81       	ld	r24, Z
    2172:	88 2f       	mov	r24, r24
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	80 72       	andi	r24, 0x20	; 32
    2178:	90 70       	andi	r25, 0x00	; 0
    217a:	00 97       	sbiw	r24, 0x00	; 0
    217c:	b9 f3       	breq	.-18     	; 0x216c <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
    217e:	ec e2       	ldi	r30, 0x2C	; 44
    2180:	f0 e0       	ldi	r31, 0x00	; 0
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	80 83       	st	Z, r24

}
    2186:	0f 90       	pop	r0
    2188:	cf 91       	pop	r28
    218a:	df 91       	pop	r29
    218c:	08 95       	ret

0000218e <UART_recieveByte>:
/*
 * Description :
 * Functional responsible for receive byte from another UART device.
 */
uint8 UART_recieveByte(void)
{
    218e:	df 93       	push	r29
    2190:	cf 93       	push	r28
    2192:	cd b7       	in	r28, 0x3d	; 61
    2194:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
    2196:	eb e2       	ldi	r30, 0x2B	; 43
    2198:	f0 e0       	ldi	r31, 0x00	; 0
    219a:	80 81       	ld	r24, Z
    219c:	88 23       	and	r24, r24
    219e:	dc f7       	brge	.-10     	; 0x2196 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
    return UDR;		
    21a0:	ec e2       	ldi	r30, 0x2C	; 44
    21a2:	f0 e0       	ldi	r31, 0x00	; 0
    21a4:	80 81       	ld	r24, Z
}
    21a6:	cf 91       	pop	r28
    21a8:	df 91       	pop	r29
    21aa:	08 95       	ret

000021ac <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
    21ac:	df 93       	push	r29
    21ae:	cf 93       	push	r28
    21b0:	00 d0       	rcall	.+0      	; 0x21b2 <UART_sendString+0x6>
    21b2:	0f 92       	push	r0
    21b4:	cd b7       	in	r28, 0x3d	; 61
    21b6:	de b7       	in	r29, 0x3e	; 62
    21b8:	9b 83       	std	Y+3, r25	; 0x03
    21ba:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    21bc:	19 82       	std	Y+1, r1	; 0x01
    21be:	0e c0       	rjmp	.+28     	; 0x21dc <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
    21c0:	89 81       	ldd	r24, Y+1	; 0x01
    21c2:	28 2f       	mov	r18, r24
    21c4:	30 e0       	ldi	r19, 0x00	; 0
    21c6:	8a 81       	ldd	r24, Y+2	; 0x02
    21c8:	9b 81       	ldd	r25, Y+3	; 0x03
    21ca:	fc 01       	movw	r30, r24
    21cc:	e2 0f       	add	r30, r18
    21ce:	f3 1f       	adc	r31, r19
    21d0:	80 81       	ld	r24, Z
    21d2:	0e 94 b0 10 	call	0x2160	; 0x2160 <UART_sendByte>
		i++;
    21d6:	89 81       	ldd	r24, Y+1	; 0x01
    21d8:	8f 5f       	subi	r24, 0xFF	; 255
    21da:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	28 2f       	mov	r18, r24
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	8a 81       	ldd	r24, Y+2	; 0x02
    21e4:	9b 81       	ldd	r25, Y+3	; 0x03
    21e6:	fc 01       	movw	r30, r24
    21e8:	e2 0f       	add	r30, r18
    21ea:	f3 1f       	adc	r31, r19
    21ec:	80 81       	ld	r24, Z
    21ee:	88 23       	and	r24, r24
    21f0:	39 f7       	brne	.-50     	; 0x21c0 <UART_sendString+0x14>
	{
		UART_sendByte(Str[i]);
		i++;
	}
}
    21f2:	0f 90       	pop	r0
    21f4:	0f 90       	pop	r0
    21f6:	0f 90       	pop	r0
    21f8:	cf 91       	pop	r28
    21fa:	df 91       	pop	r29
    21fc:	08 95       	ret

000021fe <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
    21fe:	0f 93       	push	r16
    2200:	1f 93       	push	r17
    2202:	df 93       	push	r29
    2204:	cf 93       	push	r28
    2206:	00 d0       	rcall	.+0      	; 0x2208 <UART_receiveString+0xa>
    2208:	0f 92       	push	r0
    220a:	cd b7       	in	r28, 0x3d	; 61
    220c:	de b7       	in	r29, 0x3e	; 62
    220e:	9b 83       	std	Y+3, r25	; 0x03
    2210:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    2212:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
    2214:	89 81       	ldd	r24, Y+1	; 0x01
    2216:	28 2f       	mov	r18, r24
    2218:	30 e0       	ldi	r19, 0x00	; 0
    221a:	8a 81       	ldd	r24, Y+2	; 0x02
    221c:	9b 81       	ldd	r25, Y+3	; 0x03
    221e:	8c 01       	movw	r16, r24
    2220:	02 0f       	add	r16, r18
    2222:	13 1f       	adc	r17, r19
    2224:	0e 94 c7 10 	call	0x218e	; 0x218e <UART_recieveByte>
    2228:	f8 01       	movw	r30, r16
    222a:	80 83       	st	Z, r24
    222c:	0f c0       	rjmp	.+30     	; 0x224c <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
    222e:	89 81       	ldd	r24, Y+1	; 0x01
    2230:	8f 5f       	subi	r24, 0xFF	; 255
    2232:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
    2234:	89 81       	ldd	r24, Y+1	; 0x01
    2236:	28 2f       	mov	r18, r24
    2238:	30 e0       	ldi	r19, 0x00	; 0
    223a:	8a 81       	ldd	r24, Y+2	; 0x02
    223c:	9b 81       	ldd	r25, Y+3	; 0x03
    223e:	8c 01       	movw	r16, r24
    2240:	02 0f       	add	r16, r18
    2242:	13 1f       	adc	r17, r19
    2244:	0e 94 c7 10 	call	0x218e	; 0x218e <UART_recieveByte>
    2248:	f8 01       	movw	r30, r16
    224a:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
    224c:	89 81       	ldd	r24, Y+1	; 0x01
    224e:	28 2f       	mov	r18, r24
    2250:	30 e0       	ldi	r19, 0x00	; 0
    2252:	8a 81       	ldd	r24, Y+2	; 0x02
    2254:	9b 81       	ldd	r25, Y+3	; 0x03
    2256:	fc 01       	movw	r30, r24
    2258:	e2 0f       	add	r30, r18
    225a:	f3 1f       	adc	r31, r19
    225c:	80 81       	ld	r24, Z
    225e:	83 32       	cpi	r24, 0x23	; 35
    2260:	31 f7       	brne	.-52     	; 0x222e <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
    2262:	89 81       	ldd	r24, Y+1	; 0x01
    2264:	28 2f       	mov	r18, r24
    2266:	30 e0       	ldi	r19, 0x00	; 0
    2268:	8a 81       	ldd	r24, Y+2	; 0x02
    226a:	9b 81       	ldd	r25, Y+3	; 0x03
    226c:	fc 01       	movw	r30, r24
    226e:	e2 0f       	add	r30, r18
    2270:	f3 1f       	adc	r31, r19
    2272:	10 82       	st	Z, r1
}
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	cf 91       	pop	r28
    227c:	df 91       	pop	r29
    227e:	1f 91       	pop	r17
    2280:	0f 91       	pop	r16
    2282:	08 95       	ret

00002284 <__divmodhi4>:
    2284:	97 fb       	bst	r25, 7
    2286:	09 2e       	mov	r0, r25
    2288:	07 26       	eor	r0, r23
    228a:	0a d0       	rcall	.+20     	; 0x22a0 <__divmodhi4_neg1>
    228c:	77 fd       	sbrc	r23, 7
    228e:	04 d0       	rcall	.+8      	; 0x2298 <__divmodhi4_neg2>
    2290:	2e d0       	rcall	.+92     	; 0x22ee <__udivmodhi4>
    2292:	06 d0       	rcall	.+12     	; 0x22a0 <__divmodhi4_neg1>
    2294:	00 20       	and	r0, r0
    2296:	1a f4       	brpl	.+6      	; 0x229e <__divmodhi4_exit>

00002298 <__divmodhi4_neg2>:
    2298:	70 95       	com	r23
    229a:	61 95       	neg	r22
    229c:	7f 4f       	sbci	r23, 0xFF	; 255

0000229e <__divmodhi4_exit>:
    229e:	08 95       	ret

000022a0 <__divmodhi4_neg1>:
    22a0:	f6 f7       	brtc	.-4      	; 0x229e <__divmodhi4_exit>
    22a2:	90 95       	com	r25
    22a4:	81 95       	neg	r24
    22a6:	9f 4f       	sbci	r25, 0xFF	; 255
    22a8:	08 95       	ret

000022aa <__udivmodsi4>:
    22aa:	a1 e2       	ldi	r26, 0x21	; 33
    22ac:	1a 2e       	mov	r1, r26
    22ae:	aa 1b       	sub	r26, r26
    22b0:	bb 1b       	sub	r27, r27
    22b2:	fd 01       	movw	r30, r26
    22b4:	0d c0       	rjmp	.+26     	; 0x22d0 <__udivmodsi4_ep>

000022b6 <__udivmodsi4_loop>:
    22b6:	aa 1f       	adc	r26, r26
    22b8:	bb 1f       	adc	r27, r27
    22ba:	ee 1f       	adc	r30, r30
    22bc:	ff 1f       	adc	r31, r31
    22be:	a2 17       	cp	r26, r18
    22c0:	b3 07       	cpc	r27, r19
    22c2:	e4 07       	cpc	r30, r20
    22c4:	f5 07       	cpc	r31, r21
    22c6:	20 f0       	brcs	.+8      	; 0x22d0 <__udivmodsi4_ep>
    22c8:	a2 1b       	sub	r26, r18
    22ca:	b3 0b       	sbc	r27, r19
    22cc:	e4 0b       	sbc	r30, r20
    22ce:	f5 0b       	sbc	r31, r21

000022d0 <__udivmodsi4_ep>:
    22d0:	66 1f       	adc	r22, r22
    22d2:	77 1f       	adc	r23, r23
    22d4:	88 1f       	adc	r24, r24
    22d6:	99 1f       	adc	r25, r25
    22d8:	1a 94       	dec	r1
    22da:	69 f7       	brne	.-38     	; 0x22b6 <__udivmodsi4_loop>
    22dc:	60 95       	com	r22
    22de:	70 95       	com	r23
    22e0:	80 95       	com	r24
    22e2:	90 95       	com	r25
    22e4:	9b 01       	movw	r18, r22
    22e6:	ac 01       	movw	r20, r24
    22e8:	bd 01       	movw	r22, r26
    22ea:	cf 01       	movw	r24, r30
    22ec:	08 95       	ret

000022ee <__udivmodhi4>:
    22ee:	aa 1b       	sub	r26, r26
    22f0:	bb 1b       	sub	r27, r27
    22f2:	51 e1       	ldi	r21, 0x11	; 17
    22f4:	07 c0       	rjmp	.+14     	; 0x2304 <__udivmodhi4_ep>

000022f6 <__udivmodhi4_loop>:
    22f6:	aa 1f       	adc	r26, r26
    22f8:	bb 1f       	adc	r27, r27
    22fa:	a6 17       	cp	r26, r22
    22fc:	b7 07       	cpc	r27, r23
    22fe:	10 f0       	brcs	.+4      	; 0x2304 <__udivmodhi4_ep>
    2300:	a6 1b       	sub	r26, r22
    2302:	b7 0b       	sbc	r27, r23

00002304 <__udivmodhi4_ep>:
    2304:	88 1f       	adc	r24, r24
    2306:	99 1f       	adc	r25, r25
    2308:	5a 95       	dec	r21
    230a:	a9 f7       	brne	.-22     	; 0x22f6 <__udivmodhi4_loop>
    230c:	80 95       	com	r24
    230e:	90 95       	com	r25
    2310:	bc 01       	movw	r22, r24
    2312:	cd 01       	movw	r24, r26
    2314:	08 95       	ret

00002316 <__prologue_saves__>:
    2316:	2f 92       	push	r2
    2318:	3f 92       	push	r3
    231a:	4f 92       	push	r4
    231c:	5f 92       	push	r5
    231e:	6f 92       	push	r6
    2320:	7f 92       	push	r7
    2322:	8f 92       	push	r8
    2324:	9f 92       	push	r9
    2326:	af 92       	push	r10
    2328:	bf 92       	push	r11
    232a:	cf 92       	push	r12
    232c:	df 92       	push	r13
    232e:	ef 92       	push	r14
    2330:	ff 92       	push	r15
    2332:	0f 93       	push	r16
    2334:	1f 93       	push	r17
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	cd b7       	in	r28, 0x3d	; 61
    233c:	de b7       	in	r29, 0x3e	; 62
    233e:	ca 1b       	sub	r28, r26
    2340:	db 0b       	sbc	r29, r27
    2342:	0f b6       	in	r0, 0x3f	; 63
    2344:	f8 94       	cli
    2346:	de bf       	out	0x3e, r29	; 62
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	cd bf       	out	0x3d, r28	; 61
    234c:	09 94       	ijmp

0000234e <__epilogue_restores__>:
    234e:	2a 88       	ldd	r2, Y+18	; 0x12
    2350:	39 88       	ldd	r3, Y+17	; 0x11
    2352:	48 88       	ldd	r4, Y+16	; 0x10
    2354:	5f 84       	ldd	r5, Y+15	; 0x0f
    2356:	6e 84       	ldd	r6, Y+14	; 0x0e
    2358:	7d 84       	ldd	r7, Y+13	; 0x0d
    235a:	8c 84       	ldd	r8, Y+12	; 0x0c
    235c:	9b 84       	ldd	r9, Y+11	; 0x0b
    235e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2360:	b9 84       	ldd	r11, Y+9	; 0x09
    2362:	c8 84       	ldd	r12, Y+8	; 0x08
    2364:	df 80       	ldd	r13, Y+7	; 0x07
    2366:	ee 80       	ldd	r14, Y+6	; 0x06
    2368:	fd 80       	ldd	r15, Y+5	; 0x05
    236a:	0c 81       	ldd	r16, Y+4	; 0x04
    236c:	1b 81       	ldd	r17, Y+3	; 0x03
    236e:	aa 81       	ldd	r26, Y+2	; 0x02
    2370:	b9 81       	ldd	r27, Y+1	; 0x01
    2372:	ce 0f       	add	r28, r30
    2374:	d1 1d       	adc	r29, r1
    2376:	0f b6       	in	r0, 0x3f	; 63
    2378:	f8 94       	cli
    237a:	de bf       	out	0x3e, r29	; 62
    237c:	0f be       	out	0x3f, r0	; 63
    237e:	cd bf       	out	0x3d, r28	; 61
    2380:	ed 01       	movw	r28, r26
    2382:	08 95       	ret

00002384 <_exit>:
    2384:	f8 94       	cli

00002386 <__stop_program>:
    2386:	ff cf       	rjmp	.-2      	; 0x2386 <__stop_program>
